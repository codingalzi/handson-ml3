
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. 머신러닝 프로젝트 처음부터 끝까지 &#8212; 핸즈온 머신러닝(3판)</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="1. 한눈에 보는 머신러닝" href="ml_landscape.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">핸즈온 머신러닝(3판)</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ml_landscape.html">
   1. 한눈에 보는 머신러닝
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   2. 머신러닝 프로젝트 처음부터 끝까지
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/end2end_ml_project.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/codingalzi/handson-ml3"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/codingalzi/handson-ml3/issues/new?title=Issue%20on%20page%20%2Fend2end_ml_project.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/codingalzi/handson-ml3/master?urlpath=tree/jupyter-book/end2end_ml_project.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   2.1. 실전 데이터 활용
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   2.2. 큰 그림 그리기
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     2.2.1. 데이터 정보 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     2.2.2. 학습 모델 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     2.2.3. 회귀 모델 성능 측정 지표 선택
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   2.3. 데이터 다운로드 및 적재
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     2.3.1. 데이터셋 기본 정보 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     2.3.2. 테스트셋 만들기
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   2.4. 데이터 탐색과 시각화
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id11">
     2.4.1. 지리적 데이터 시각화
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id12">
     2.4.2. 상관관계 조사
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   2.5. 머신러닝 알고리즘 훈련용 데이터 준비
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id14">
     2.5.1. 데이터 정제와 전처리
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id15">
     2.5.2. 데이터 정제
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id16">
     2.5.3. 범주형 특성 다루기: 원-핫 인코딩
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id17">
     2.5.4. 특성 스케일링
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id18">
     2.5.5. 사용자 정의 변환기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#combinedattributesadder">
       2.5.5.1. 예제: CombinedAttributesAdder 변환기 클래스 선언
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id19">
       2.5.5.2. 상속하면 좋은 클래스
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id20">
     2.5.6. 변환 파이프라인
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id21">
       2.5.6.1. 수치형 특성 변환 파이프라인
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id22">
       2.5.6.2. 수치형 / 범주형 특성 전처리 과정 통합 파이프라인
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id23">
   2.6. 모델 선택과 훈련
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id24">
     2.6.1. 훈련셋에서 훈련하고 평가하기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id25">
       2.6.1.1. 선형 회귀 모델(4장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id26">
       2.6.1.2. 선형 회귀 모델의 훈련셋 대상 예측 성능
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id27">
       2.6.1.3. 결정트리 회귀 모델(6장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id28">
       2.6.1.4. 결정트리 회귀 모델의 훈련셋 대상 예측 성능
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id29">
     2.6.2. 교차 검증을 사용한 평가
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#k">
       2.6.2.1. k-겹 교차 검증
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#k-10">
       2.6.2.2. 예제: 결정 트리 모델 교차 검증 (k = 10인 경우)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id30">
       2.6.2.3. 예제: 선형 회귀 모델 교차 검증 (k = 10 인 경우)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id31">
       2.6.2.4. 앙상블 학습 (7장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id32">
       2.6.2.5. 랜덤 포레스트 회귀 모델 (7장)
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   2.7. 모델 세부 튜닝
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id34">
     2.7.1. 그리드 탐색
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id35">
       2.7.1.1. 예제: 그리드 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id36">
       2.7.1.2. 그리드 탐색 결과
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id37">
     2.7.2. 랜덤 탐색
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id38">
       2.7.2.1. 예제: 랜덤 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id39">
       2.7.2.2. 랜덤 탐색 결과
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id40">
     2.7.3. 앙상블 방법
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id41">
     2.7.4. 최상의 모델과 오차 분석
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id42">
     2.7.5. 테스트 셋으로 시스템 평가하기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id43">
       2.7.5.1. 최상의 모델 성능 평가
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id44">
       2.7.5.2. 최상의 모델 성능 배포
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id45">
       2.7.5.3. 데이터셋 및 모델 백업
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>머신러닝 프로젝트 처음부터 끝까지</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   2.1. 실전 데이터 활용
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   2.2. 큰 그림 그리기
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     2.2.1. 데이터 정보 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     2.2.2. 학습 모델 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     2.2.3. 회귀 모델 성능 측정 지표 선택
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   2.3. 데이터 다운로드 및 적재
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     2.3.1. 데이터셋 기본 정보 확인
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     2.3.2. 테스트셋 만들기
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   2.4. 데이터 탐색과 시각화
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id11">
     2.4.1. 지리적 데이터 시각화
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id12">
     2.4.2. 상관관계 조사
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   2.5. 머신러닝 알고리즘 훈련용 데이터 준비
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id14">
     2.5.1. 데이터 정제와 전처리
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id15">
     2.5.2. 데이터 정제
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id16">
     2.5.3. 범주형 특성 다루기: 원-핫 인코딩
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id17">
     2.5.4. 특성 스케일링
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id18">
     2.5.5. 사용자 정의 변환기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#combinedattributesadder">
       2.5.5.1. 예제: CombinedAttributesAdder 변환기 클래스 선언
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id19">
       2.5.5.2. 상속하면 좋은 클래스
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id20">
     2.5.6. 변환 파이프라인
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id21">
       2.5.6.1. 수치형 특성 변환 파이프라인
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id22">
       2.5.6.2. 수치형 / 범주형 특성 전처리 과정 통합 파이프라인
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id23">
   2.6. 모델 선택과 훈련
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id24">
     2.6.1. 훈련셋에서 훈련하고 평가하기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id25">
       2.6.1.1. 선형 회귀 모델(4장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id26">
       2.6.1.2. 선형 회귀 모델의 훈련셋 대상 예측 성능
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id27">
       2.6.1.3. 결정트리 회귀 모델(6장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id28">
       2.6.1.4. 결정트리 회귀 모델의 훈련셋 대상 예측 성능
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id29">
     2.6.2. 교차 검증을 사용한 평가
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#k">
       2.6.2.1. k-겹 교차 검증
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#k-10">
       2.6.2.2. 예제: 결정 트리 모델 교차 검증 (k = 10인 경우)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id30">
       2.6.2.3. 예제: 선형 회귀 모델 교차 검증 (k = 10 인 경우)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id31">
       2.6.2.4. 앙상블 학습 (7장)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id32">
       2.6.2.5. 랜덤 포레스트 회귀 모델 (7장)
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id33">
   2.7. 모델 세부 튜닝
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id34">
     2.7.1. 그리드 탐색
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id35">
       2.7.1.1. 예제: 그리드 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id36">
       2.7.1.2. 그리드 탐색 결과
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id37">
     2.7.2. 랜덤 탐색
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id38">
       2.7.2.1. 예제: 랜덤 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id39">
       2.7.2.2. 랜덤 탐색 결과
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id40">
     2.7.3. 앙상블 방법
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id41">
     2.7.4. 최상의 모델과 오차 분석
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id42">
     2.7.5. 테스트 셋으로 시스템 평가하기
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id43">
       2.7.5.1. 최상의 모델 성능 평가
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id44">
       2.7.5.2. 최상의 모델 성능 배포
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id45">
       2.7.5.3. 데이터셋 및 모델 백업
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="ch-end2end">
<span id="id1"></span><h1><span class="section-number">2. </span>머신러닝 프로젝트 처음부터 끝까지<a class="headerlink" href="#ch-end2end" title="Permalink to this headline">¶</a></h1>
<p><strong>감사의 글</strong></p>
<p>자료를 공개한 저자 오렐리앙 제롱과 강의자료를 지원한 한빛아카데미에게 진심어린 감사를 전합니다.</p>
<p><strong>소스코드</strong></p>
<p>본문 내용의 일부를 파이썬으로 구현한 내용은
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/handson-ml3/blob/master/notebooks/code_end2end_ml_project.ipynb">(구글코랩) 머신러닝 프로젝트 처음부터 끝까지</a>에서
확인할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<p>주택 가격을 예측하는 다양한 <strong>회귀 모델</strong><font size="2">regression model</font>의
훈련 과정을 이용하여 머신러닝 시스템의 전체 훈련 과정을 상세히 살펴본다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-01d.png" width="600"></div><div class="section" id="id2">
<h2><span class="section-number">2.1. </span>실전 데이터 활용<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>다양하고 수많은 실전 데이터를 모아놓은 데이터 저장소를
머신러닝 공부에 잘 활용할 수 있어야 한다.
여기서 사용하는 데이터는 1990년 미국 캘리포니아 주에서 수집한 인구조사 자료이며,
데이터의 원본은 다양한 공개 저장소에서 다운로드할 수 있다.</p>
<p>가장 유명한 데이터 저장소는 다음과 같다.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.openml.org/">OpenML</a></p></li>
<li><p><a class="reference external" href="http://www.kaggle.com/datasets">캐글(Kaggle) 데이터셋</a></p></li>
<li><p><a class="reference external" href="https://paperswithcode.com/">페이퍼스 위드 코드</a></p></li>
<li><p><a class="reference external" href="http://archive.ics.uci.edu/ml">UC 얼바인(UC Irvine) 대학교 머신러닝 저장소</a></p></li>
<li><p><a class="reference external" href="https://registry.opendata.aws">아마존 AWS 데이터셋</a></p></li>
<li><p><a class="reference external" href="https://www.tensorflow.org/datasets">텐서플로우 데이터셋</a></p></li>
</ul>
</div>
<div class="section" id="id3">
<h2><span class="section-number">2.2. </span>큰 그림 그리기<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>머신러닝으로 해결하고자 하는 문제를 파악하기 위해
주어진 데이터에 대한 기초적인 정보,
문제 정의,
문제 해결법 등을 구상해야 한다.</p>
<div class="section" id="id4">
<h3><span class="section-number">2.2.1. </span>데이터 정보 확인<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>1990년도에 시행된 미국 캘리포니아 주의 20,640개 구역별 인구조사 데이터는
경도, 위도, 중간 주택 연도, 방의 총 개수, 침실 총 개수, 인구, 가구 수, 중간 소득, 중간 주택 가격, 해안 근접도
등을 포함한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/LA-USA01.png" width="600"></div></div>
<div class="section" id="id5">
<h3><span class="section-number">2.2.2. </span>학습 모델 확인<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>구역별 중간 주택 가격을 예측하는 시스템에 활용될
회귀 모델을 훈련시킨다.
훈련시킬 모델의 특성은 다음과 같다.</p>
<ul class="simple">
<li><p>지도 학습: 구역별 ‘중간 주택 가격’을 레이블(타깃)로 지정한다.</p></li>
<li><p>회귀: 가격을 예측한다. 보다 세분화하면 다중 회귀이지 단변량 회귀 모델이다.</p>
<ul>
<li><p>다중 회귀<font size="2">multiple regression</font>: 구역별로 여러 특성을 주택 가격 예측에 사용한다.</p></li>
<li><p>단변량 회귀<font size="2">univariate regression</font>: 구역별로 한 종류의 값만 예측한다.</p></li>
</ul>
</li>
<li><p>배치 학습: 빠르게 변하는 데이터에 적응할 필요가 없으며, 데이터셋의 크기도 충분히 작다.</p></li>
</ul>
<div class="info admonition">
<p class="admonition-title">다변량 회귀</p>
<p>다변량 회귀<font size="2">multivariate regression</font>는 여러 종류의 값을 동시에 예측한다.</p>
</div>
</div>
<div class="section" id="id6">
<h3><span class="section-number">2.2.3. </span>회귀 모델 성능 측정 지표 선택<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>훈련중인 회귀 모델의 성능을 평가하는 지표로
예측값과 타깃 사이의 오차를 활용하는 아래 두 방식 중 하나를 사용한다.</p>
<ul class="simple">
<li><p>평균 제곱근 오차(RMSE)</p></li>
<li><p>평균 절대 오차(MAE)</p></li>
</ul>
<p><strong>평균 제곱근 오차(RMSE)</strong></p>
<p>평균 제곱근 오차<font size="2">Root Mean Square Error</font>는
예측값과 타깃 사이의 오차의 제곱의 평균값이다.
수학에서는 <strong>유클리디안 노름</strong> 또는 <strong><span class="math notranslate nohighlight">\(\ell_2\)</span> 노름</strong>으로 불린다.</p>
<div class="math notranslate nohighlight">
\[\text{RMSE}(\mathbf X, h) = \sqrt{\frac 1 m \sum_{i=1}^{m} (h(\mathbf x^{(i)}) - y^{(i)})^2}\]</div>
<p>위 수식에 사용된 기호의 의미는 다음과 같다.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf X\)</span>: 모델 성능 평가에 사용되는 데이터셋 전체 샘플들의 특성값들로 구성된 행렬, 레이블(타겟) 제외.</p></li>
<li><p><span class="math notranslate nohighlight">\(m\)</span>: <span class="math notranslate nohighlight">\(\mathbf X\)</span>의 행의 수. 즉, 훈련 데이터셋 크기.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf x^{(i)}\)</span>: <span class="math notranslate nohighlight">\(i\)</span> 번째 샘플의 전체 특성값 벡터. 레이블(타겟) 제외.</p></li>
<li><p><span class="math notranslate nohighlight">\(y^{(i)}\)</span>: <span class="math notranslate nohighlight">\(i\)</span> 번째 샘플의 레이블(타깃)</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span>: 예측 함수</p></li>
<li><p><span class="math notranslate nohighlight">\(h(\mathbf x^{(i)})\)</span>: <span class="math notranslate nohighlight">\(i\)</span>번째 샘플에 대한 예측 값. <span class="math notranslate nohighlight">\(\hat y^{(i)}\)</span>로 표기되기도 함.</p></li>
</ul>
<div class="proof example admonition" id="2d-array">
<p class="admonition-title"><span class="caption-number">Example 2.1 </span> (훈련셋과 2D 어레이)</p>
<div class="example-content section" id="proof-content">
<p>모델 훈련에 사용되는 훈련셋에
<span class="math notranslate nohighlight">\(m\)</span> 개의 샘플이 포함되어 있고 각각의 샘플이 <span class="math notranslate nohighlight">\(n\)</span> 개의 특성을 갖는다면
훈련셋은 <span class="math notranslate nohighlight">\((m, n)\)</span> 모양의 numpy의 2D 어레이로 지정된다.</p>
<p>예를 들어, <span class="math notranslate nohighlight">\(m = 5\)</span>, <span class="math notranslate nohighlight">\(n = 4\)</span> 이면 훈련셋 <span class="math notranslate nohighlight">\(\mathbf X\)</span>는 다음과 같이
표현된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">118.29</span><span class="p">,</span> <span class="mf">33.91</span><span class="p">,</span> <span class="mi">1416</span><span class="p">,</span> <span class="mi">38372</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">114.30</span><span class="p">,</span> <span class="mf">34.92</span><span class="p">,</span> <span class="mi">2316</span><span class="p">,</span> <span class="mi">41442</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">120.38</span><span class="p">,</span> <span class="mf">35.21</span><span class="p">,</span> <span class="mi">3444</span><span class="p">,</span> <span class="mi">29303</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">122.33</span><span class="p">,</span> <span class="mf">32.95</span><span class="p">,</span> <span class="mi">2433</span><span class="p">,</span> <span class="mi">24639</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">139.31</span><span class="p">,</span> <span class="mf">33.33</span><span class="p">,</span> <span class="mi">1873</span><span class="p">,</span> <span class="mi">50736</span><span class="p">]])</span>
</pre></div>
</div>
<p>각각의 <span class="math notranslate nohighlight">\(\mathbf{x}^{(i)}\)</span>는 <span class="math notranslate nohighlight">\(i\)</span> 번째 행에 해당한다.
예를 들어 <span class="math notranslate nohighlight">\(\mathbf{x}^{(1)}\)</span>은 첫째 행의 1D 어레이를 가리킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">118.29</span><span class="p">,</span> <span class="mf">33.91</span><span class="p">,</span> <span class="mi">1416</span><span class="p">,</span> <span class="mi">38372</span><span class="p">])</span>
</pre></div>
</div>
<p>단변량 회귀에서 <span class="math notranslate nohighlight">\(y^{(i)}\)</span> 는 보통 부동소수점을 가리키며,
다변량 회귀에서는 <span class="math notranslate nohighlight">\(\mathbf{x}^{(i)}\)</span> 처럼
여러 개의 타깃 값으로 구성된 1D 어레이로 표현된다.</p>
</div>
</div><p><strong>평균 절대 오차(MAE)</strong></p>
<p>평균 절대 오차<font size="2">Mean Absolute Error</font>는
맨해튼 노름 또는 <span class="math notranslate nohighlight">\(\ell_1\)</span> 노름으로도 불리며
예측값과 타깃 사이의 오차의 평균값이다.</p>
<div class="math notranslate nohighlight">
\[\text{MAE}(\mathbf X, h) = \frac 1 m \sum_{i=1}^{m} \mid h(\mathbf x^{(i)}) - y^{(i)} \mid\]</div>
<p>훈련 데이터셋에 이상치가 많이 포함된 경우 주로 사용되지만,
그렇지 않다면 일반적으로 RMSE가 선호된다.</p>
</div>
</div>
<div class="section" id="id7">
<h2><span class="section-number">2.3. </span>데이터 다운로드 및 적재<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>캐리포니아 주택가격 데이터셋은 매우 유명하여 많은 공개 저장소에서 다운로드할 수 있다.
여기서는 저자가 자신의 깃허브에 압축파일로 저장한 파일을 다운로드해서 사용한다.</p>
<div class="section" id="id8">
<h3><span class="section-number">2.3.1. </span>데이터셋 기본 정보 확인<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>pandas의 데이터프레임으로 데이터셋을 적재하여 기본적인 데이터 구조를 훑어볼 수 있다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">head()</span></code> 메서드 활용</strong></p>
<p>데이터프레임 객체의 처음 5개 샘플을 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-05.png" width="600"></div><p><strong><code class="docutils literal notranslate"><span class="pre">info()</span></code> 메서드 활용</strong></p>
<p>데이터셋의 정보를 요약해서 보여준다.</p>
<ul class="simple">
<li><p>구역 수: 20,640개. 한 구역의 인구는 600에서 3,000명 사이.</p></li>
<li><p>구역별로 경도, 위도, 중간 주택 연도, 해안 근접도 등 총 10개의 조사 항목</p>
<ul>
<li><p>‘해안 근접도’는 범주형 특성이고 나머지는 수치형 특성.</p></li>
</ul>
</li>
<li><p>‘방의 총 개수’의 경우 207개의 null 값, 즉 결측치 존재.</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-05a.png" width="450"></div><p><strong>범주형 특성 탐색</strong></p>
<p>‘해안 근접도’는 5개의 범주로 구분된다.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>특성값</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&lt;1H OCEAN</p></td>
<td><p>해안에서 1시간 이내</p></td>
</tr>
<tr class="row-odd"><td><p>INLAND</p></td>
<td><p>내륙</p></td>
</tr>
<tr class="row-even"><td><p>NEAR OCEAN</p></td>
<td><p>해안 근처</p></td>
</tr>
<tr class="row-odd"><td><p>NEAR BAY</p></td>
<td><p>샌프란시스코의 Bay Area 구역</p></td>
</tr>
<tr class="row-even"><td><p>ISLAND</p></td>
<td><p>섬</p></td>
</tr>
</tbody>
</table>
<p><strong>수치형 특성 탐색</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">describe()</span></code> 메서드는 수치형 특성들의 정보를 요약해서 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/housing-describe.png"></div><p><code class="docutils literal notranslate"><span class="pre">hist()</span></code> 메서드는 수치형 특성별 히스토그램을 그린다.
히스토그램을 통해 각 특성별 데이터셋의 다양한 정보를 확인할 수 있다.</p>
<ul class="simple">
<li><p>각 특성마다 사용되는 단위와 스케일(척도)가 다르다.</p></li>
<li><p>일부 특성은 한쪽으로 치우쳐저 있다.</p></li>
<li><p>일부 특성은 값을 제한한 것으로 보인다.</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/feature-histogram.png" width="600px"></div></div>
<div class="section" id="id9">
<h3><span class="section-number">2.3.2. </span>테스트셋 만들기<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>모델 학습 시작 이전에 준비된 데이터셋을 훈련셋과 테스트셋으로 구분해야 한다.
테스트셋은 훈련 과정중에 전혀 사용되지 않으며 보통 전체 데이터셋의 20% 정도 이하로
전체 데이터셋의 크기에 따라 적절히 조절한다.</p>
<p>테스트셋에 대한 정보는 절대로 모델 훈련에 이용하지 않아야 한다.
그렇지 않으면 미래에 실전에서 사용되는 데이터를 미리 안다고 가정하고 모델을 훈련시키는
것과 동일하게 되며, 이런 방식은 매우 잘못된 모델을 훈련시킬 위험을 키운다.</p>
<p>데이터셋을 훈련셋과 데이터셋으로 구분할 때 보통 계층적 샘플링을 사용한다.</p>
<p><strong>계층적 샘플링</strong></p>
<p>각 계층별로 적절한 샘플을 추측하는 기법이다.
이유는 계층별로 충분한 크기의 샘플이 포함되도록 지정해야 학습 과정에서 편향이 발생하지 않는다.
예를 들어, 특정 소득 구간에 포함된 샘플이 과하게 적거나 많으면 해당 계층의 중요도가 과대 혹은 과소 평가될 수 있다.</p>
<p>캘리포니아 데이터셋의 중간 소득을 대상으로하는 히스토그램을 보면
대부분 구역의 중간 소득이 1.5~6.0, 즉 15,000 달러에서 60,000 달러 사이인 것을 알 수 있다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-08.png" width="400"></div><p>소득 구간을 아래 숫자들을 기준으로 5개로 구분한 다음에 계층적 샘플링을 이용하여
훈련셋과 테스트셋을 구분하면 무작위 샘플링 방식과는 분명히 다르게
계층별 샘플의 비율을 거의 동일하게 유지한다.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>구간</p></th>
<th class="text-align:left head"><p>범위</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:left"><p>0 ~ 1.5</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:left"><p>1.5 ~ 3.0</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>3</p></td>
<td class="text-align:left"><p>3.0 ~ 4.5</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>4</p></td>
<td class="text-align:left"><p>4.5 ~ 6.0</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>5</p></td>
<td class="text-align:left"><p>6.0 ~</p></td>
</tr>
</tbody>
</table>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-07.png" width="500"></div></div>
</div>
<div class="section" id="id10">
<h2><span class="section-number">2.4. </span>데이터 탐색과 시각화<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>테스트셋을 제외한 훈련셋에 대해서 시각화를 이용하여 데이터셋을 탐색한다.</p>
<div class="section" id="id11">
<h3><span class="section-number">2.4.1. </span>지리적 데이터 시각화<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>경도와 위도 정보를 이용하여 구역을 산포도로 나타내면 인구의 밀집 정도를 확인할 수 있다.
예를 들어, 샌프란시스코의 베이 에어리어, LA, 샌디에고 등 유명 대도시의 인구 밀도가 높다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-09.png" width="500"></div><p>유명 대도시의 인구 밀도가 높은 특정 구역의 주택 가격이 높다는 일반적인 사실 또한 산포도록 확인할 수 있다.
산포도를 그릴 때 해당 구역의 중간 주택 가격을 색상으로,
인구밀도는 원의 크기로 활용한 결과는 다음과 같다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-11.png" width="500"></div></div>
<div class="section" id="id12">
<h3><span class="section-number">2.4.2. </span>상관관계 조사<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>중간 주택 가격 특성과 다른 특성 사이의 선형 상관관계를 나타내는 상관계수는 다음과 같다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-12.png" width="600"></div><p><strong>상관계수의 특징</strong></p>
<p>상관계수는 -1에서 1 사이의 값으로 표현된다.</p>
<ul class="simple">
<li><p>1에 가까울 수록: 강한 양의 선형 상관관계</p></li>
<li><p>-1에 가까울 수록: 강한 음의 선형 상관관계</p></li>
<li><p>0에 가까울 수록: 매우 약한 선형 상관관계</p></li>
</ul>
<div class="warning admonition">
<p class="admonition-title">상관계수와 상관관계</p>
<p>상관계수가 0이라는 것은 선형 관계가 없다는 의미이지 서로 아무런 상관관계가 없다는 의미는 아니다.
또한 선형계수가 1이라 하더라도 산점도에서 데이터의 선형관계를 보여주는 직선의 기울기는 아무런 상관이 없다.
아래 그림은 상관계수의 이런 특성을 잘 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-14.png" width="400"></div>
<p>&lt;그림 출처: <a class="reference external" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">위키백과</a>&gt;</p>
</div>
<p>상관계수를 통해 중간 주택 가격과 중간 소득의 상관계수가 0.68로 가장 높다는 사실을 확인한다.
즉, 중간 소득이 올라가면 중간 주택 가격도 상승하는 경향이 있다.
하지만 점들이 너무 넓게 퍼져 있어서 완벽한 선형관계와는 거리 멀다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-13.png" width="400"></div><p>위 산점도는 다음 사항들에 주의할 것을 잘 보여준다.</p>
<ul class="simple">
<li><p>50만 달러에서 보이는 수평선은 가격을 제한한 결과로 보여진다.</p></li>
<li><p>45만, 35만, 28만, 그 아래 정도에서도 수평선이 존재하는데 이유는 알려지지 않았다.</p></li>
<li><p>이러한 이상한 모델이 형태를 학습하지 못하도록 해당 구역을 제거하는 것이
일반적으로 좋다. 하지만 여기서는 그대로 두고 사용한다.</p></li>
</ul>
<p>경우에 따라 기존의 특성을 조합해서 새로운 특성을 활용할 수도 있다.
예를 들어 구역별 방의 총 개수와 침실의 총 개수 대신 아래 특성이 보다 유용해 보인다.</p>
<ul class="simple">
<li><p>가구당 방 개수(<code class="docutils literal notranslate"><span class="pre">rooms_for_house</span></code>)</p></li>
<li><p>방 하나당 침실 개수(<code class="docutils literal notranslate"><span class="pre">bedrooms_ratio</span></code>)</p></li>
<li><p>가구당 인원(<code class="docutils literal notranslate"><span class="pre">people_perhouse</span></code>)</p></li>
</ul>
<p>실제로 세 특성을 새로 추가한 다음에 상관계수를 확인하면
방 하나당 침실 개수와 중간 주택 가격 사이의 선형 연관성이
특성 조합에 사용된 다른 특성들에 비해 높게 나타난다.</p>
</div>
</div>
<div class="section" id="id13">
<h2><span class="section-number">2.5. </span>머신러닝 알고리즘 훈련용 데이터 준비<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>머신러닝 모델 훈련에 사용되는 알고리즘을 이용하려면
적재된 데이터셋을 적절하게 준비해야 한다.
즉, 데이터 정제와 전처리 과정을 수행해서
바로 모델 훈련에 사용될 수 있도록 해야 한다.
정제와 전처리 모든 과정은 <strong>파이프라인</strong><font size="2">pipeline</font>으로
자동화해서 언제든지 재활용할 수 있도록 해야 한다.</p>
<p>먼저 앞서 계층별로 구분된 훈련셋 <code class="docutils literal notranslate"><span class="pre">strat_train_set</span></code> 을
입력 데이터셋 과
타깃 데이터셋으로 또다시 구분한다.</p>
<ul>
<li><p>입력 데이터셋: 중간 주택 가격 특성이 제거된 훈련셋</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span> <span class="o">=</span> <span class="n">strat_train_set</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>타깃 데이터셋: 중간 주택 가격 특성으로만 구성된 훈련셋</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing_labels</span> <span class="o">=</span> <span class="n">strat_train_set</span><span class="p">[</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
<p>데이터 준비는 기본적으로 입력 데이터셋만을 대상으로 <strong>정제</strong><font size="2">cleaning</font>와
<strong>전처리</strong><font size="2">preprocessing</font> 단계로 실행된다.
타깃 데이터셋은 결측치가 없는 경우라면 일반적으로 정제와 전처리 대상이 아니지만
경우에 따라 변환이 요구될 수 있다.
예를 들어, 타깃 데이터셋의 히스토그램이 지나치게 한쪽으로 치우치는 모양을 띠면
로그 함수를 적용하여 값을 변환하는 것이 권장된다.</p>
<div class="info admonition">
<p class="admonition-title">테스트셋 전처리</p>
<p>테스트셋에 대한 전처리와 구분은 모든 훈련이 완성된 후에
훈련됨 모델의 성능을 측정할 때
기존에 완성된 파이트라인을 이용하면 된다.</p>
</div>
<div class="section" id="id14">
<h3><span class="section-number">2.5.1. </span>데이터 정제와 전처리<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>데이터 정제는 결측치 처리, 이상치 및 노이즈 데이터 제거 등을 의미한다.
캘리포니아 주택 가격 데이터셋은 구역별 전체 방 개수(<code class="docutils literal notranslate"><span class="pre">total_rooms</span></code>) 특성에서 결측치가 일부 포함되어 있지만
이상치 또는 노이즈 데이터는 없다고 가정한다.</p>
<p>전처리는 수치형 특성과 범주형 특성을 나누어 수행한다.</p>
<ul class="simple">
<li><p>수치형 특성에 대한 전처리</p>
<ul>
<li><p>특성 스케일링</p></li>
<li><p>특성 조합</p></li>
</ul>
</li>
<li><p>범주형 특성 전처리 과정</p>
<ul>
<li><p>원-핫-인코딩<font size="2">one-hot-encoding</font></p></li>
</ul>
</li>
</ul>
<p>데이터 정제와 전처리의 모든 과정은 데이터셋에 포함된 샘플을
한꺼번에 지정된 방식으로 변환한다.
따라서 모든 변환 과정을 자동화는
<strong>파이프라인</strong><font size="2">pipeline</font> 기법을 활용해야 한다.</p>
<p><strong>사이킷런 API 활용</strong></p>
<p>사이킷런<font size="2">Scikit-Learn</font>에서 제공하는
머신러닝 관련 API를 활용하여 데이터 준비 과정을 자동화하는 파이프라인을 쉽게 구현할 수 있다.
파이프라인 구성이 간단한 이유는 사이킷런의 API를 합성하는 기능일 기본으로 지원하기 때문이다.
이를 이해하려면 먼저 사이킷런이 제공하는 API의 유형을 구분할 줄 알아야 한다.</p>
<p>사이킷런의 API는 크게 세 종류의 클래스로 나뉜다.</p>
<ul class="simple">
<li><p>추정기<font size="2">estimator</font></p>
<ul>
<li><p>인자로 주어진 데이터셋 객체 관련된 특정 값 계산</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드: 계산된 특정 값으로 업데이트된 데이터 객체 자신 반환</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>변환기<font size="2">transformer</font></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드 이외에 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 가 계산한 값을 이용하여 데이터셋을 변환하는 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드 지원.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드와 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 연속해서 호출하는 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드도 지원.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>예측기<font size="2">predictor</font></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드 이외에 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 가 계산한 값을 이용하여
타깃을 예측하는 <code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드 지원.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드가 예측한 값의 성능을 측정하는 <code class="docutils literal notranslate"><span class="pre">score()</span></code> 메서드 지원.</p></li>
<li><p>일부 예측기는 추정치의 신뢰도를 평가하는 기능도 제공</p></li>
</ul>
</li>
</ul>
<p>사이킷런의 API는 또한 적절한
<strong>하이퍼파라미터</strong><font size="2">hyperparameter</font>로 초기화되어 있으며
추정 및 변화 관정에 필요한 모든 파라미터를 저장하며 효율적으로 관리한다.</p>
<div class="info admonition">
<p class="admonition-title">하이퍼파라미터 대 파라미터</p>
<p>사이킷런 API의 하이퍼파라미터는 해당 객체를 생성할 때 사용되는 값을 가리킨다.
즉, API 객체를 생성하기 위해 해당 API 클래스의 생성자인
<code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 메서드를 호출할 때 사용하는 인자를 가리킨다.</p>
<p>반면에 파라미터는 지정된 API 객체의 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드가 실행되는 과정에
주어진 입력 데이터셋 관련해서 계산하는 값을 가리킨다.
추정기, 변환기, 예측기는 각각의 역할에 맞는 파라미터를 계산한다.</p>
</div>
</div>
<div class="section" id="id15">
<h3><span class="section-number">2.5.2. </span>데이터 정제<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>입력 데이터셋의 <code class="docutils literal notranslate"><span class="pre">total_bedrooms</span></code> 특성에 207개 구역에 대한 값이 null 값으로 채워져 있다.
즉, 일부 구역에 대한 전체 방의 개수 정보가 누락되었다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/null-value01.png" width="800"></div><p>머신러닝 모델은 결측치가 있는 데이터셋을 잘 활용하지 못한다.
따라서 아래 옵션 중 하나를 선택해서 데이터를 정제해야 한다.</p>
<ul class="simple">
<li><p>옵션 1: 해당 구역 제거</p></li>
<li><p>옵션 2: 해당 특성 삭제</p></li>
<li><p>옵션 3: 평균값, 중앙값, 0, 주변에 위치한 값 등 특정 값으로 채우기.</p></li>
</ul>
<p>여기서는 중앙값으로 채우는 옵션 3 방식을 사이킷런의 <code class="docutils literal notranslate"><span class="pre">SimpleImputer</span></code> 변환기를 이용하여 적용한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/null-value02.png" width="800"></div></div>
<div class="section" id="id16">
<h3><span class="section-number">2.5.3. </span>범주형 특성 다루기: 원-핫 인코딩<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>해안 근접도(<code class="docutils literal notranslate"><span class="pre">ocean_proximity</span></code>)는 수가 아닌 아닌 5 개의 범주를 나타내는 텍스트를 값으로 사용한다.
그런데 머신러닝 모델은 일반적으로 텍스트 데이터를 처리하지 못한다.</p>
<p>가장 단순한 해결책으로 5 개의 범주를 정수로 변환할 수 있다.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>범주</p></th>
<th class="head"><p>숫자</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&lt;1H OCEAN</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>INLAND</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>ISLAND</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>NEAR BAY</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>NEAR OCEAN</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>하지만 이 방식은 수의 크기 특성을 모델이 활용할 수 있기에 위험하다.
예를 들어 바닷가 근처(<code class="docutils literal notranslate"><span class="pre">NEAR</span> <span class="pre">OCEAN</span></code>)에 위치한 주택이 가장 비쌀 것으로 모델이 학습할 수 있다.</p>
<p>범주형 특성을 수치화하는 가장 일반적인 방식은
<strong>원-핫 인코딩</strong><font size="2">one-hot encoding</font>이다.
원-핫 인코딩은 수치화된 범주들 사이의 크기 비교를 피하기 위해 더미(dummy) 특성을 활용한다.</p>
<p>원-핫 인코딩을 적용하면 해안 근접도 특성을 다섯 개의 범주 전부를
새로운 특성으로 대체한다.
다섯 개의 특성에 사용되는 값은 다음 방식으로 지정한다.</p>
<ul class="simple">
<li><p>해당 카테고리의 특성값: 1</p></li>
<li><p>나머지 카테고리의 특성값: 0</p></li>
</ul>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">INLAND</span></code>를 해안 근접도 특성값으로 간던 샘플은 다음 모양의 특성값을 갖게 된다.</p>
<p><code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code></p>
<p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">OneHotEncoder</span></code> 변환기가 원-핫-인코딩을 지원한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-16.png" width="600"></div></div>
<div class="section" id="id17">
<h3><span class="section-number">2.5.4. </span>특성 스케일링<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>머신러닝 알고리즘은 입력 데이터셋의 특성값들의
<strong>스케일</strong><font size="2">scale</font>(척도)이 다르면 제대로 작동하지 않는다.
따라서 모든 특성의 척도를 통일하는 <strong>스케일링</strong><font size="2">scaling</font> 전처리가 요구된다.</p>
<div class="warning admonition">
<p class="admonition-title">타깃 데이터셋과 스케일링</p>
<p>타깃(레이블) 데이터셋에 대한 스케일링은 굳이 필요하지 않다.
다만 타깃 데이터셋의 분포가 한쪽으로 치우친 경우 로그 함수를 적용할 필요가 있을 수는 있다.
로그 함수 적용은 스케일링처럼 특성값들을 0과 1 근처의 값으로 몰아가지는 않는 대신에
데이터의 분포가 보다 좌우 대칭을 갖도록 변화시킨다.</p>
</div>
<p>스케일링은 보통 아래 두 가지 방식을 사용한다.</p>
<ul class="simple">
<li><p>min-max 스케일링</p></li>
<li><p>표준화</p></li>
</ul>
<p><strong>min-max 스케일링</strong></p>
<p><strong>정규화</strong>(normalization)라고도 불리며
아래 식을 이용하여 모든 특성값을 0에서 1 사이의 값으로 변환한다.
단, <span class="math notranslate nohighlight">\(max\)</span> 와 <span class="math notranslate nohighlight">\(min\)</span> 은 각각 특성값들의 최댓값과 최솟값을 가리킨다.</p>
<div class="math notranslate nohighlight">
\[
\frac{x-min}{max-min}
\]</div>
<p>min-max 스케일링은 이상치에 매우 민감하다.
예를 들어 이상치가 매우 크면 분모가 매우 커져서 변환된 값이 0 근처에 몰리게 된다.
사이킷런의 <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> 변환기가 min-max 스케일링을 지원한다.</p>
<p><strong>표준화(standardization)</strong></p>
<p>아래식을 이용하여 특성값을 변환한다.
단, <span class="math notranslate nohighlight">\(\mu\)</span> 와 <span class="math notranslate nohighlight">\(\sigma\)</span> 는 각각 특성값들의 평균값과 표준편차를 가리킨다.</p>
<div class="math notranslate nohighlight">
\[
\frac{x-\mu}{\sigma}
\]</div>
<p>변환된 데이터셋은 <strong>표준정규분포</strong>를 따르며,
이상치에 상대적으로 영향을 덜 받는다.
여기서는 사이킷런의 <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> 변환기를 이용하여 표준화를 적용한다.</p>
<div class="warning admonition">
<p class="admonition-title">변환기 사용법</p>
<p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 과 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 두 메서드 훈련셋에 대해서만 사용한다.
반면에 테스트셋, 검증셋, 새로운 데이터 등에 대해서는 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드만 적용한다.
즉, 훈련셋을 대상으로 계산된 파라미터를 이용하여
훈련 이외의 경우에 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 확인하여 데이터를 변환한다.</p>
</div>
</div>
<div class="section" id="id18">
<h3><span class="section-number">2.5.5. </span>사용자 정의 변환기<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>아래 특성 추가 용도 변환기 클래스 직접 선언하기</p>
<ul>
<li><p>가구당 방 개수(rooms for household)</p></li>
<li><p>방 하나당 침실 개수(bedrooms for room)</p></li>
<li><p>가구당 인원(population per household)</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>변환기 클래스: <code class="docutils literal notranslate"><span class="pre">fit()</span></code>, <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 구현하면 됨.</p>
<ul>
<li><p>주의: fit() 메서드의 리턴값은 self</p></li>
</ul>
</li>
</ul>
<div class="section" id="combinedattributesadder">
<h4><span class="section-number">2.5.5.1. </span>예제: CombinedAttributesAdder 변환기 클래스 선언<a class="headerlink" href="#combinedattributesadder" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 메서드: 생성되는 모델의 <strong>하이퍼파라미터</strong> 지정 용도</p>
<ul>
<li><p>모델에 대한 적절한 하이퍼파라미터를 튜닝할 때 유용하게 활용됨.</p></li>
<li><p>예제: 방 하나당 침실 개수 속성 추가 여부</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드: 계산해야 하는 파라미터가 없음. 바로 <code class="docutils literal notranslate"><span class="pre">self</span></code> 리턴</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드: 넘파이 어레이를 입력받아 속성을 추가한 어레이를 반환</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CombinedAttributesAdder</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_bedrooms_per_room</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h4><span class="section-number">2.5.5.2. </span>상속하면 좋은 클래스<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BaseEstimator</span></code> 상속: 하이퍼파라미터 튜닝 자동화에 필요한 <code class="docutils literal notranslate"><span class="pre">get_params()</span></code>, <code class="docutils literal notranslate"><span class="pre">set_params()</span></code> 메서드 제공</p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TransformerMixin</span></code> 상속: <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 자동 생성</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/custom-transformer.png" width="350"></div>
<p>&lt;그림 아이디어 출처: <a class="reference external" href="https://towardsdatascience.com/get-the-most-out-of-scikit-learn-with-object-oriented-programming-d01fef48b448">Get the Most out of scikit-learn with Object-Oriented Programming</a>&gt;</p>
</div>
</div>
<div class="section" id="id20">
<h3><span class="section-number">2.5.6. </span>변환 파이프라인<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>모든 전처리 단계가 정확한 순서대로 진행되어야 함</p></li>
</ul>
<ul class="simple">
<li><p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> 클래스를 이용하여 파이프라인 변환기 객체 생성 가능</p></li>
</ul>
<div class="section" id="id21">
<h4><span class="section-number">2.5.6.1. </span>수치형 특성 변환 파이프라인<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
        <span class="p">(</span><span class="s1">&#39;imputer&#39;</span><span class="p">,</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;attribs_adder&#39;</span><span class="p">,</span> <span class="n">CombinedAttributesAdder</span><span class="p">()),</span>
        <span class="p">(</span><span class="s1">&#39;std_scaler&#39;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
    <span class="p">])</span>
</pre></div>
</div>
<ul class="simple">
<li><p>인자: 이름과 추정기로 이루어진 쌍들의 리스트</p></li>
</ul>
<ul class="simple">
<li><p>마지막 추정기 제외 나머지 추정기는 모두 변환기이어야 함.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드 지원</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>파이프라인으로 정의된 추정기의 유형은 마지막 추정기의 유형과 동일</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pipeline</span></code>는 변환기. 이유는 <code class="docutils literal notranslate"><span class="pre">std_scaler</span></code>가 변환기이기 때문임.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_pipeline.fit()</span></code> 호출:</p>
<ul>
<li><p>마지막 단계 이전 추정기: <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메소드 연속 호출.
즉, 변환기가 실행될 때마다 변환도 동시에 진행.</p></li>
<li><p>마지막 추정기: <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드 호출</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id22">
<h4><span class="section-number">2.5.6.2. </span>수치형 / 범주형 특성 전처리 과정 통합 파이프라인<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">ColumnTransformer</span></code> 클래스를 이용하여 특성별로 지정된 전처리를 처리할 수 있도록 지정 가능</p></li>
</ul>
<ul class="simple">
<li><p>인자: (이름, 추정기, 적용 대상 열(column) 리스트) 튜플로 이루어진 리스트</p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드에 pandas의 데이터프레임을 직접 인자로 사용 가능</p></li>
</ul>
<ul class="simple">
<li><p>수치형 특성: <code class="docutils literal notranslate"><span class="pre">num_pipeline</span></code> 변환기</p>
<ul>
<li><p>적용 대상 열(columns): <code class="docutils literal notranslate"><span class="pre">list(housing_num)</span></code></p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>범주형 특성: <code class="docutils literal notranslate"><span class="pre">OneHotEncoder</span></code> 변환기</p>
<ul>
<li><p>적용 대상 열(columns): <code class="docutils literal notranslate"><span class="pre">[&quot;ocean_proximity&quot;]</span></code></p></li>
</ul>
</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_attribs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">housing_num</span><span class="p">)</span>
<span class="n">cat_attribs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ocean_proximity&quot;</span><span class="p">]</span>

<span class="n">full_pipeline</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">([</span>
        <span class="p">(</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="n">num_pipeline</span><span class="p">,</span> <span class="n">num_attribs</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">OneHotEncoder</span><span class="p">(),</span> <span class="n">cat_attribs</span><span class="p">),</span>
    <span class="p">])</span>

<span class="n">housing_prepared</span> <span class="o">=</span> <span class="n">full_pipeline</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">housing</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id23">
<h2><span class="section-number">2.6. </span>모델 선택과 훈련<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>목표 달성에 필요한 두 요소를 결정해야함</p>
<ul>
<li><p>학습 모델</p></li>
<li><p>회귀 모델 성능 측정 지표</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>목표: 구역별 중간 주택 가격 예측 모델</p></li>
</ul>
<ul class="simple">
<li><p>학습 모델: 회귀 모델</p></li>
</ul>
<ul class="simple">
<li><p>회귀 모델 성능 측정 지표: 평균 제곱근 오차(RMSE)를 기본으로 사용</p></li>
</ul>
<div class="section" id="id24">
<h3><span class="section-number">2.6.1. </span>훈련셋에서 훈련하고 평가하기<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>지금까지 한 일</p>
<ul>
<li><p>훈련셋 / 테스트셋 구분</p></li>
<li><p>변환 파이프라인을 활용한 데이터 전처리</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>이제 할 일</p>
<ul>
<li><p>예측기 모델 선택 후 훈련시키기</p></li>
<li><p>예제: 선형 회귀, 결정트리 회귀</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>예측기 모델 선택 후 훈련과정은 매우 단순함.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 전처리 처리가 된 훈련 데이터셋에 적용</p></li>
</ul>
</li>
</ul>
<div class="section" id="id25">
<h4><span class="section-number">2.6.1.1. </span>선형 회귀 모델(4장)<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>선형 회귀 모델 생성: 사이킷런의 <strong><code class="docutils literal notranslate"><span class="pre">LinearRegression</span></code></strong> 클래스 활용</p></li>
</ul>
<ul class="simple">
<li><p>훈련 및 예측</p>
<ul>
<li><p>훈련: <code class="docutils literal notranslate"><span class="pre">LinearRegression</span></code> 모델은 무어-펜로즈 역행렬을 이용하여 파라미터 직접 계산 (4장 참조)</p></li>
<li><p>예측: (여기서는 연습 용도로) 훈련셋에 포함된 몇 개 데이터를 대상으로 예측 실행</p></li>
</ul>
</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="n">lin_reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
<span class="n">lin_reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>

<span class="n">lin_reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h4><span class="section-number">2.6.1.2. </span>선형 회귀 모델의 훈련셋 대상 예측 성능<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>RMSE(평균 제곱근 오차)가 68628.198 정도로 별로 좋지 않음.</p></li>
</ul>
<ul class="simple">
<li><p>훈련된 모델이 훈련셋에 <strong>과소적합</strong> 됨.</p>
<ul>
<li><p>보다 좋은 특성을 찾거나 더 강력한 모델을 적용해야 함.</p></li>
<li><p>보다 좋은 특성 예제: 로그 함수를 적용한 인구수 등</p></li>
<li><p>모델에 사용되는 규제(regulaization, 4장)를 완화할 수도 있지만 위 모델에선 어떤 규제도 적용하지 않았음.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id27">
<h4><span class="section-number">2.6.1.3. </span>결정트리 회귀 모델(6장)<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>결정 트리 모델은 데이터에서 복잡한 비선형 관계를 학습할 때 사용</p></li>
</ul>
<ul class="simple">
<li><p>결정트리 회귀 모델 생성: 사이킷런의 <strong><code class="docutils literal notranslate"><span class="pre">DecisionTreeRegressor</span></code></strong> 클래스 활용</p></li>
</ul>
<ul class="simple">
<li><p>훈련 및 예측</p>
<ul>
<li><p>예측은 훈련셋에 포함된 몇 개 데이터를 대상으로 예측 실행</p></li>
</ul>
</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span>

<span class="n">tree_reg</span> <span class="o">=</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">tree_reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>

<span class="n">housing_predictions</span> <span class="o">=</span> <span class="n">tree_reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h4><span class="section-number">2.6.1.4. </span>결정트리 회귀 모델의 훈련셋 대상 예측 성능<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>RMSE(평균 제곱근 오차)가 0으로 완벽해 보임.</p></li>
</ul>
<ul class="simple">
<li><p>훈련된 모델이 훈련셋에 심각하게 <strong>과대적합</strong> 됨.</p>
<ul>
<li><p>실전 상황에서 RMSE가 0이 되는 것은 불가능.</p></li>
<li><p>훈련셋이 아닌 테스트셋에 적용할 경우 RMSE가 크게 나올 것임.</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id29">
<h3><span class="section-number">2.6.2. </span>교차 검증을 사용한 평가<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>테스트셋을 사용하지 않으면서 훈련 과정을 평가할 수 있음.</p></li>
</ul>
<ul class="simple">
<li><p><strong>교차 검증</strong> 활용</p></li>
</ul>
<div class="section" id="k">
<h4><span class="section-number">2.6.2.1. </span>k-겹 교차 검증<a class="headerlink" href="#k" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>훈련셋을 <strong>폴드</strong>(fold)라 불리는 k-개의 부분 집합으로 무작위로 분할</p></li>
<li><p>총 k 번 지정된 모델을 훈련</p>
<ul>
<li><p>훈련할 때마다 매번 다른 하나의 폴드 선택하여 검증 데이터셋으로 활용</p></li>
<li><p>다른 (k-1) 개의 폴드를 이용해 훈련</p></li>
</ul>
</li>
<li><p>최종적으로 k 번의 평가 결과가 담긴 배열 생성</p></li>
</ul>
<ul class="simple">
<li><p>k = 5인 경우</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/cross-val10.png" width="400"></div></div>
<div class="section" id="k-10">
<h4><span class="section-number">2.6.2.2. </span>예제: 결정 트리 모델 교차 검증 (k = 10인 경우)<a class="headerlink" href="#k-10" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">tree_reg</span><span class="p">,</span> <span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">,</span>
                         <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">tree_rmse_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">scores</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>k-겹 교차 검증의 모델 학습 과정에서 성능을 측정할 때 높을 수록 좋은 <strong>효용함수</strong> 활용</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">scoring=&quot;neg_mean_squared_error&quot;</span></code></p></li>
<li><p>RMSE의 음숫값</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>교차 검증의 RMSE: 다시 음숫값(<code class="docutils literal notranslate"><span class="pre">-scores</span></code>) 사용</p>
<ul>
<li><p>평균 RMSE: 약 71407</p></li>
<li><p>별로 좋지 않음.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id30">
<h4><span class="section-number">2.6.2.3. </span>예제: 선형 회귀 모델 교차 검증 (k = 10 인 경우)<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lin_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">lin_reg</span><span class="p">,</span> <span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">,</span>
                             <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_squared_error&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">lin_rmse_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">lin_scores</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>교차 검증의 RMSE 평균: 약 69052</p>
<ul>
<li><p>결정트리 회귀 모델보다 좋음.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id31">
<h4><span class="section-number">2.6.2.4. </span>앙상블 학습 (7장)<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>여러 개의 다른 모델을 모아서 하나의 모델을 만드는 기법</p></li>
</ul>
<ul class="simple">
<li><p>머신러닝 알고리즘의 성능을 극대화는 방법 중 하나</p></li>
</ul>
</div>
<div class="section" id="id32">
<h4><span class="section-number">2.6.2.5. </span>랜덤 포레스트 회귀 모델 (7장)<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>앙상블 학습에 사용되는 하나의 기법</p></li>
</ul>
<ul class="simple">
<li><p>무작위로 선택한 특성을 이용하는 결정 트리 여러 개를 훈련 시킨 후
훈련된 모델들의 평균 예측값을 예측값으로 사용하는 모델</p></li>
</ul>
<ul class="simple">
<li><p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">RandomForestRegressor</span></code> 클래스 활용</p></li>
</ul>
<ul class="simple">
<li><p>훈련 및 예측</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span>

<span class="n">forest_reg</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">forest_reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>

<span class="n">housing_predictions</span> <span class="o">=</span> <span class="n">forest_reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>랜덤 포레스트 모델의 RMSE: 약 50182</p>
<ul>
<li><p>지금까지 사용해본 모델 중 최고</p></li>
<li><p>하지만 여전히 과대적합되어 있음.</p></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="id33">
<h2><span class="section-number">2.7. </span>모델 세부 튜닝<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>살펴 본 모델 중에서 <strong>랜덤 포레스트</strong> 모델의 성능이 가장 좋았음</p></li>
</ul>
<ul class="simple">
<li><p>가능성이 높은 모델을 선정한 후에 <strong>모델 세부 설정을 튜닝</strong>해야함</p></li>
</ul>
<ul class="simple">
<li><p>튜닝을 위한 세 가지 방식</p>
<ul>
<li><p><strong>그리드 탐색</strong></p></li>
<li><p><strong>랜덤 탐색</strong></p></li>
<li><p><strong>앙상블 방법</strong></p></li>
</ul>
</li>
</ul>
<div class="section" id="id34">
<h3><span class="section-number">2.7.1. </span>그리드 탐색<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>지정한 하이퍼파라미터의 모든 조합을 교차검증하여 최선의 하이퍼파라미터 조합 찾기</p></li>
</ul>
<ul class="simple">
<li><p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> 활용</p></li>
</ul>
<div class="section" id="id35">
<h4><span class="section-number">2.7.1.1. </span>예제: 그리드 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="n">param_grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]},</span>
    <span class="p">{</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">:</span> <span class="p">[</span><span class="kc">False</span><span class="p">],</span> <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
  <span class="p">]</span>

<span class="n">forest_reg</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">forest_reg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                           <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span>
                           <span class="n">return_train_score</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>총 (3x4 + 2x3 = 18) 가지의 경우 확인</p></li>
</ul>
<ul class="simple">
<li><p>5-겹 교차검증(<code class="docutils literal notranslate"><span class="pre">cv=5</span></code>)이므로, 총 (18x5 = 90)번 훈련함.</p></li>
</ul>
</div>
<div class="section" id="id36">
<h4><span class="section-number">2.7.1.2. </span>그리드 탐색 결과<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>최고 성능의 랜덤 포레스트 하이퍼파라미터가 다음과 같음.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">max_features</span></code>: 8</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>: 30</p></li>
<li><p>지정된 구간의 최고값들이기에 구간을 좀 더 넓히는 게 좋아 보임</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>최고 성능의 랜덤 포레스트에 대한 교차검증 RMSE: 49682</p>
<ul>
<li><p>하나의 랜덤 포레스트보다 좀 더 좋아졌음.</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id37">
<h3><span class="section-number">2.7.2. </span>랜덤 탐색<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>그리드 탐색은 적은 수의 조합을 실험해볼 때 유용</p></li>
</ul>
<ul class="simple">
<li><p>조합의 수가 커지거나, 설정된 탐색 공간이 커지면 랜덤 탐색이 효율적</p>
<ul>
<li><p>설정값이 연속적인 값을 다루는 경우 랜덤 탐색이 유용</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">RandomizedSearchCV</span></code> 추정기가 랜덤 탐색을 지원</p></li>
</ul>
<div class="section" id="id38">
<h4><span class="section-number">2.7.2.1. </span>예제: 랜덤 탐색으로 랜덤 포레스트 모델에 대한 최적 조합 찾기<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="n">param_distribs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">200</span><span class="p">),</span>
        <span class="s1">&#39;max_features&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span>
    <span class="p">}</span>

<span class="n">forest_reg</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">rnd_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">forest_reg</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_distribs</span><span class="p">,</span>
                                <span class="n">n_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">rnd_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing_prepared</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n_iter=10</span></code>: 랜덤 탐색이 총 10회 진행</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>와 <code class="docutils literal notranslate"><span class="pre">max_features</span></code> 값을 지정된 구간에서 무작위 선택</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cv=5</span></code>: 5-겹 교차검증. 따라서 랜덤 포레스트 학습이 (10x5=50)번 이루어짐.</p></li>
</ul>
</div>
<div class="section" id="id39">
<h4><span class="section-number">2.7.2.2. </span>랜덤 탐색 결과<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>최고 성능의 랜덤 포레스트 하이퍼파라미터가 다음과 같음.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">max_features</span></code>: 7</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>: 180</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>최고 성능의 랜덤 포레스트에 대한 교차검증 RMSE: 49150</p></li>
</ul>
</div>
</div>
<div class="section" id="id40">
<h3><span class="section-number">2.7.3. </span>앙상블 방법<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>결정 트리 모델 하나보다 랜덤 포레스트처럼 여러 모델로 이루어진 모델이 보다 좋은 성능을 낼 수 있음.</p></li>
</ul>
<ul class="simple">
<li><p>또한 최고 성능을 보이는 서로 다른 개별 모델을 조합하면 보다 좋은 성능을 얻을 수 있음</p></li>
</ul>
<ul class="simple">
<li><p>7장에서 자세히 다룸</p></li>
</ul>
</div>
<div class="section" id="id41">
<h3><span class="section-number">2.7.4. </span>최상의 모델과 오차 분석<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>그리드 탐색과 랜덤 탐색 등을 통해 얻어진 최상의 모델을 분석해서 문제에 대한 좋은 통창을 얻을 수 있음</p></li>
</ul>
<ul class="simple">
<li><p>예를 들어, 최상의 랜덤 포레스트 모델에서 사용된 특성들의 중요도를 확인하여 일부 특성을 제외할 수 있음.</p>
<ul>
<li><p>중간 소득(median income)과 INLAND(내륙, 해안 근접도)가 가장 중요한 특성으로 확인됨</p></li>
<li><p>해안 근접도의 다른 네 가지 특성은 별로 중요하지 않음</p></li>
<li><p>중요도가 낮은 특성은 삭제할 수 있음.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/feature-importance.png" width="400"></div></div>
<div class="section" id="id42">
<h3><span class="section-number">2.7.5. </span>테스트 셋으로 시스템 평가하기<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>최고 성능 모델 확인: 예를 들어, 그리드 탐색으로 찾은 최적 모델 사용</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">final_model</span> <span class="o">=</span> <span class="n">grid_search</span><span class="o">.</span><span class="n">best_estimator_</span>
</pre></div>
</div>
<ol class="simple">
<li><p>테스트셋 전처리</p>
<ul class="simple">
<li><p>전처리 파이프라인의 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 직접 활용</p></li>
<li><p><strong>주의</strong>: <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드는 전혀 사용하지 않음</p></li>
</ul>
</li>
</ol>
<ol class="simple">
<li><p>최고 성능 모델을 이용하여 예측하기</p></li>
</ol>
<ol class="simple">
<li><p>최고 성능 모델 평가 및 론칭</p></li>
</ol>
<div class="section" id="id43">
<h4><span class="section-number">2.7.5.1. </span>최상의 모델 성능 평가<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>테스트셋에 대한 최고 성능 모델의 RMSE: 47730</p></li>
</ul>
</div>
<div class="section" id="id44">
<h4><span class="section-number">2.7.5.2. </span>최상의 모델 성능 배포<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/model-launching01.png" width="600"></div></div>
<div class="section" id="id45">
<h4><span class="section-number">2.7.5.3. </span>데이터셋 및 모델 백업<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>완성된 모델은 항상 백업해 두어야 함. 업데이트된 모델이 적절하지 않은 경우 이전 모델로 되돌려야 할 수도 있음.</p>
<ul>
<li><p>백업된 모델과 새 모델을 쉽게 비교할 수 있음.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>동일한 이유로 모든 버전의 데이터셋을 백업해 두어야 함.</p>
<ul>
<li><p>업데이트 과정에서 데이터셋이 오염될 수 있기 때문임.</p></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="ml_landscape.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">1. </span>한눈에 보는 머신러닝</p>
        </div>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By 코딩알지<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>