

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>2. 머신러닝 프로젝트 처음부터 끝까지 &#8212; 핸즈온 머신러닝(3판)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'end2end_ml_project';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. 분류" href="classification.html" />
    <link rel="prev" title="1. 한눈에 보는 머신러닝" href="ml_landscape.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    <p class="title logo__title">핸즈온 머신러닝(3판)</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ml_landscape.html">1. 한눈에 보는 머신러닝</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">2. 머신러닝 프로젝트 처음부터 끝까지</a></li>
<li class="toctree-l1"><a class="reference internal" href="classification.html">3. 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="training_models.html">4. 모델 훈련</a></li>
<li class="toctree-l1"><a class="reference internal" href="svm.html">5. 서포트 벡터 머신</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_trees.html">6. 결정트리</a></li>
<li class="toctree-l1"><a class="reference internal" href="ensemble_learning_random_forests.html">7. 앙상블 학습과 랜덤 포레스트</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimensionality_reduction.html">8. 차원 축소</a></li>
<li class="toctree-l1"><a class="reference internal" href="unsupervised_learning.html">9. 비지도 학습</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/codingalzi/handson-ml3/blob/master/jupyter-book/end2end_ml_project.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/handson-ml3" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/handson-ml3/issues/new?title=Issue%20on%20page%20%2Fend2end_ml_project.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/end2end_ml_project.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>머신러닝 프로젝트 처음부터 끝까지</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">2.1. 실전 데이터 활용</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">2.2. 큰 그림 그리기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">2.2.1. 데이터 정보 확인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">2.2.2. 훈련 모델 확인</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">2.3. 데이터 훑어보기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">2.3.1. 데이터 기본 정보 확인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">2.3.2. 훈련셋과 테스트셋</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">2.4. 데이터 탐색과 시각화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">2.4.1. 지리적 데이터 시각화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.4.2. 상관관계 조사</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">2.5. 데이터 준비</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">2.5.1. 데이터 정제와 전처리</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.5.2. 데이터 정제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.5.3. 범주형 특성 전처리: 원-핫 인코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">2.5.4. 수치형 특성 전처리: 크기 조정</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2.5.5. 사용자 정의 변환기</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#functiontransformer">2.5.5.1. <code class="docutils literal notranslate"><span class="pre">FunctionTransformer</span></code> 변환기</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.5.5.2. 사용자 정의 변환기 클래스 선언: 군집 변환기</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">2.5.6. 변환 파이프라인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">2.5.7. 캘리포니아 데이터셋 변환 파이프라인</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">2.6. 모델 선택과 훈련</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">2.6.1. 모델 훈련과 평가</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">2.6.2. 교차 검증</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">2.7. 모델 미세 조정</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">2.7.1. 그리드 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">2.7.2. 랜덤 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">2.7.3. 최적 모델 활용</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">2.8. 최적 모델 저장과 활용</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">2.9. 연습문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="ch-end2end">
<span id="id1"></span><h1><span class="section-number">2. </span>머신러닝 프로젝트 처음부터 끝까지<a class="headerlink" href="#ch-end2end" title="Permalink to this heading">#</a></h1>
<p><strong>감사의 글</strong></p>
<p>자료를 공개한 저자 오렐리앙 제롱과 강의자료를 지원한 한빛아카데미에게 진심어린 감사를 전합니다.</p>
<p><strong>소스코드</strong></p>
<p>본문 내용의 일부를 파이썬으로 구현한 내용은
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/handson-ml3/blob/master/notebooks/code_end2end_ml_project.ipynb">(구글코랩) 머신러닝 프로젝트 처음부터 끝까지</a>에서
확인할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<p>주택 가격을 예측하는 다양한 <strong>회귀 모델</strong><font size="2">regression model</font>의
훈련 과정을 이용하여 머신러닝 시스템의 전체 훈련 과정을 살펴본다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-01d.png" width="600"></div><p>특히 데이터 정제 및 전처리 과정으로 구성된 데이터 준비와
최적의 모델을 찾는 과정을 상세히 소개한다.</p>
<p><strong>슬라이드</strong></p>
<p>본문 내용을 요약한
<a class="reference external" href="https://github.com/codingalzi/handson-ml3/raw/master/slides/slides-end2end_ml_project-1.pdf">슬라이드 1부</a>,
<a class="reference external" href="https://github.com/codingalzi/handson-ml3/raw/master/slides/slides-end2end_ml_project-2.pdf">슬라이드 2부</a>,
<a class="reference external" href="https://github.com/codingalzi/handson-ml3/raw/master/slides/slides-end2end_ml_project-3.pdf">슬라이드 3부</a>를
다운로드할 수 있다.</p>
<section id="id2">
<h2><span class="section-number">2.1. </span>실전 데이터 활용<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>다양한 실전 데이터를 모아놓은 데이터 저장소를
머신러닝 공부에 잘 활용할 수 있어야 한다.
가장 유명한 데이터 저장소는 다음과 같다.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.openml.org/">OpenML</a></p></li>
<li><p><a class="reference external" href="http://www.kaggle.com/datasets">캐글(Kaggle) 데이터셋</a></p></li>
<li><p><a class="reference external" href="https://paperswithcode.com/">페이퍼스 위드 코드</a></p></li>
<li><p><a class="reference external" href="http://archive.ics.uci.edu/ml">UC 얼바인(UC Irvine) 대학교 머신러닝 저장소</a></p></li>
<li><p><a class="reference external" href="https://registry.opendata.aws">아마존 AWS 데이터셋</a></p></li>
<li><p><a class="reference external" href="https://www.tensorflow.org/datasets">텐서플로우 데이터셋</a></p></li>
</ul>
<p>여기서는 1990년 미국 캘리포니아 주에서 수집한 인구조사 데이터를 사용하며,
데이터의 원본은 다양한 공개 저장소에서 다운로드할 수 있다.
아래 그림은 원본 csv 파일의 일부 내용을 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/housing-data.png" width="800"></div></section>
<section id="id3">
<h2><span class="section-number">2.2. </span>큰 그림 그리기<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>머신러닝으로 해결하고자 하는 문제를 파악하기 위해
주어진 데이터에 대한 기초적인 정보를 확인하고,
문제 파악 및 해결법 등을 구상해야 한다.</p>
<section id="id4">
<h3><span class="section-number">2.2.1. </span>데이터 정보 확인<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>1990년도에 시행된 미국 캘리포니아 주의 20,640개 구역별 인구조사 데이터는
경도, 위도, 중간 주택 연도, 방의 총 개수, 침실 총 개수, 인구, 가구 수, 중간 소득, 중간 주택 가격, 해안 근접도
등 총 10개의 특성을 포함한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/LA-USA01.png" width="600"></div></section>
<section id="id5">
<h3><span class="section-number">2.2.2. </span>훈련 모델 확인<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h3>
<p><strong>훈련 모델 종류</strong></p>
<p>구역별 중간 주택 가격을 예측하는 시스템에 활용될
<strong>회귀 모델</strong>을 훈련시키고자 한다.
훈련시킬 모델의 특성은 다음과 같다.</p>
<ul class="simple">
<li><p>지도 학습: 구역별 ‘중간 주택 가격’을 타깃<font size='2'>target</font>으로 지정한다.</p></li>
<li><p>회귀: 가격을 예측한다. 보다 세분화하면 다중 회귀이자 단변량 회귀 모델이다.</p>
<ul>
<li><p>다중 회귀<font size="2">multiple regression</font>: 구역별로 여러 특성을 주택 가격 예측에 사용한다.</p></li>
<li><p>단변량 회귀<font size="2">univariate regression</font>: 구역별로 한 종류의 값만 예측한다.</p></li>
</ul>
</li>
<li><p>배치 학습: 빠르게 변하는 데이터에 적응할 필요가 없으며, 데이터셋의 크기도 충분히 작다.</p></li>
</ul>
<div class="info admonition">
<p class="admonition-title">다변량 회귀</p>
<p>다변량 회귀<font size="2">multivariate regression</font>는 여러 종류의 값을 동시에 예측한다.</p>
</div>
<p><strong>훈련 모델 성능 측정 지표</strong></p>
<p>회귀 모델의 성능은 일반적으로 예측값과 타깃 사이의 오차를 활용하는 아래
두 평가하는 지표 중 하나를 사용한다.</p>
<ul class="simple">
<li><p>평균 제곱근 오차(RMSE)</p></li>
<li><p>평균 절대 오차(MAE)</p></li>
</ul>
<p><strong>평균 제곱근 오차</strong><font size="2">Root Mean Square Error</font>(RMSE)는
예측값과 타깃 사이의 오차의 제곱의 평균값이다.
<strong>유클리디안 노름</strong> 또는 <strong><span class="math notranslate nohighlight">\(\ell_2\)</span> 노름</strong>으로 불린다.</p>
<div class="math notranslate nohighlight">
\[\text{RMSE}(\mathbf X, h) = \sqrt{\frac 1 m \sum_{i=0}^{m-1} (h(\mathbf x^{(i)}) - y^{(i)})^2}\]</div>
<p>위 수식에 사용된 기호의 의미는 다음과 같다.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf X\)</span>: 훈련용 입력 데이터셋 전체 샘플들의 특성값으로 구성된 행렬, 타깃 제외.</p></li>
<li><p><span class="math notranslate nohighlight">\(m\)</span>: <span class="math notranslate nohighlight">\(\mathbf X\)</span>의 행의 수. 즉, 훈련셋 크기.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf x^{(i)}\)</span>: <span class="math notranslate nohighlight">\(i\)</span> 번째 샘플의 특성값 벡터.</p></li>
<li><p><span class="math notranslate nohighlight">\(y^{(i)}\)</span>: <span class="math notranslate nohighlight">\(i\)</span> 번째 샘플의 타깃</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span>: 예측 함수</p></li>
<li><p><span class="math notranslate nohighlight">\(h(\mathbf x^{(i)})\)</span>: <span class="math notranslate nohighlight">\(i\)</span>번째 샘플에 대한 예측 값. <span class="math notranslate nohighlight">\(\hat y^{(i)}\)</span> 로 표기되기도 함.</p></li>
</ul>
<div class="proof example admonition" id="2d-array">
<p class="admonition-title"><span class="caption-number">Example 2.1 </span> (훈련셋과 2D 어레이)</p>
<section class="example-content" id="proof-content">
<p>모델 훈련에 사용되는 훈련셋에
<span class="math notranslate nohighlight">\(m\)</span> 개의 샘플이 포함되어 있고 각각의 샘플이 <span class="math notranslate nohighlight">\(n\)</span> 개의 특성을 갖는다면
훈련셋은 <span class="math notranslate nohighlight">\((m, n)\)</span> 모양의 numpy의 2D 어레이로 지정된다.</p>
<p>예를 들어, <span class="math notranslate nohighlight">\(m = 5\)</span>, <span class="math notranslate nohighlight">\(n = 4\)</span> 이면 훈련셋 <span class="math notranslate nohighlight">\(\mathbf X\)</span>는 다음과 같이
표현된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">118.29</span><span class="p">,</span> <span class="mf">33.91</span><span class="p">,</span> <span class="mi">1416</span><span class="p">,</span> <span class="mi">38372</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">114.30</span><span class="p">,</span> <span class="mf">34.92</span><span class="p">,</span> <span class="mi">2316</span><span class="p">,</span> <span class="mi">41442</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">120.38</span><span class="p">,</span> <span class="mf">35.21</span><span class="p">,</span> <span class="mi">3444</span><span class="p">,</span> <span class="mi">29303</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">122.33</span><span class="p">,</span> <span class="mf">32.95</span><span class="p">,</span> <span class="mi">2433</span><span class="p">,</span> <span class="mi">24639</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">139.31</span><span class="p">,</span> <span class="mf">33.33</span><span class="p">,</span> <span class="mi">1873</span><span class="p">,</span> <span class="mi">50736</span><span class="p">]])</span>
</pre></div>
</div>
<p>각각의 <span class="math notranslate nohighlight">\(\mathbf{x}^{(i)}\)</span>는 <span class="math notranslate nohighlight">\(i\)</span> 번 행에 해당한다.
예를 들어 <span class="math notranslate nohighlight">\(\mathbf{x}^{(0)}\)</span>은 0번 행의 1D 어레이를 가리킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">118.29</span><span class="p">,</span> <span class="mf">33.91</span><span class="p">,</span> <span class="mi">1416</span><span class="p">,</span> <span class="mi">38372</span><span class="p">])</span>
</pre></div>
</div>
<p>단변량 회귀에서 <span class="math notranslate nohighlight">\(y^{(i)}\)</span> 는 보통 부동소수점을 가리키며,
다변량 회귀에서는 <span class="math notranslate nohighlight">\(\mathbf{x}^{(i)}\)</span> 처럼
여러 개의 타깃 값으로 구성된 1D 어레이로 표현된다.</p>
</section>
</div><p><strong>평균 절대 오차</strong><font size="2">Mean Absolute Error</font>(MAE)는
<strong>맨해튼 노름</strong> 또는 <strong><span class="math notranslate nohighlight">\(\ell_1\)</span> 노름</strong>으로도 불리며
예측값과 타깃 사이의 오차의 평균값이다.</p>
<div class="math notranslate nohighlight">
\[\text{MAE}(\mathbf X, h) = \frac 1 m \sum_{i=0}^{m-1} \mid h(\mathbf x^{(i)}) - y^{(i)} \mid\]</div>
<p>훈련셋에 이상치가 많이 포함된 경우 주로 사용되지만,
그렇지 않다면 일반적으로 RMSE가 선호된다.</p>
</section>
</section>
<section id="id6">
<h2><span class="section-number">2.3. </span>데이터 훑어보기<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h2>
<p>캘리포니아 주택가격 데이터셋은 매우 유명하여 많은 공개 저장소에서 다운로드할 수 있다.
여기서는 깃허브 리포지토리에 압축파일로 저장한 파일을 다운로드해서 사용하며
<code class="docutils literal notranslate"><span class="pre">housing</span></code> 변수가 가리키도록 적재되었다고 가정한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">housing</span></code> 변수: 캘리포티아 주택 가격 데이터를 담고 있는 csv 파일을 적재하여 생성된 데이터 프레임 할당</p></li>
</ul>
<section id="id7">
<h3><span class="section-number">2.3.1. </span>데이터 기본 정보 확인<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<p>pandas의 데이터프레임으로 데이터셋을 적재하여 기본적인 데이터 구조를 훑어볼 수 있다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">head()</span></code> 메서드 활용</strong></p>
<p>데이터프레임 객체의 처음 5개 샘플을 보여준다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-05.png" width="800"></div><p><strong><code class="docutils literal notranslate"><span class="pre">info()</span></code> 메서드 활용</strong></p>
<p>데이터셋의 정보를 요약해서 보여준다.</p>
<ul class="simple">
<li><p>구역 수: 20,640개. 한 구역의 인구는 600에서 3,000명 사이.</p></li>
<li><p>구역별로 경도, 위도, 중간 주택 연도, 해안 근접도 등 총 10개의 조사 항목</p>
<ul>
<li><p>‘해안 근접도’는 범주형 특성이고 나머지는 수치형 특성.</p></li>
</ul>
</li>
<li><p>‘방의 총 개수’의 경우 207개의 null 값, 즉 결측치 존재.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-05a.png" width="350"></div><p><strong>범주형 특성 탐색</strong></p>
<p>‘해안 근접도’는 5개의 범주로 구분된다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>특성값</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&lt;1H OCEAN</p></td>
<td><p>해안에서 1시간 이내</p></td>
</tr>
<tr class="row-odd"><td><p>INLAND</p></td>
<td><p>내륙</p></td>
</tr>
<tr class="row-even"><td><p>NEAR OCEAN</p></td>
<td><p>해안 근처</p></td>
</tr>
<tr class="row-odd"><td><p>NEAR BAY</p></td>
<td><p>샌프란시스코의 Bay Area 구역</p></td>
</tr>
<tr class="row-even"><td><p>ISLAND</p></td>
<td><p>섬</p></td>
</tr>
</tbody>
</table>
<p><strong>수치형 특성 탐색</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">describe()</span></code> 메서드는 수치형 특성들의 정보를 요약해서 보여준다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/housing-describe.png"></div>
<br><p><strong>수치형 특성별 히스토그램</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">hist()</span></code> 메서드는 수치형 특성별 히스토그램을 그린다.
히스토그램을 통해 각 특성별 데이터셋의 다양한 정보를 확인할 수 있다.</p>
<ul class="simple">
<li><p>각 특성마다 사용되는 단위와 스케일(척도)가 다르다.</p></li>
<li><p>일부 특성은 한쪽으로 치우쳐저 있다.</p></li>
<li><p>일부 특성은 값을 제한한 것으로 보인다.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/feature-histogram.png" width="600px"></div></section>
<section id="id8">
<h3><span class="section-number">2.3.2. </span>훈련셋과 테스트셋<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<p>모델 학습 시작 이전에 준비된 데이터셋을 <strong>훈련셋</strong>과 <strong>테스트셋</strong>으로 구분해야 한다.
테스트셋은 훈련 과정중에 전혀 사용되지 않으며 보통 전체 데이터셋의 20% 정도 이하로
선택하며, 전체 데이터셋의 크기에 따라 테스트셋의 크기가 너무 크지 않게
비율을 적절히 조절한다.</p>
<p>테스트셋에 대한 정보는 절대로 모델 훈련에 이용하지 않는다.
만약 이용하게 되면 미래에 실전에서 사용되는 데이터를 미리 안다고 가정하고 모델을 훈련시키는
것과 동일하게 되어 매우 잘못된 모델을 훈련시킬 위험을 키우게 된다.</p>
<p>데이터셋을 훈련셋과 데이터셋으로 구분할 때 보통 계층 샘플링을 사용한다.</p>
<p><strong>계층 샘플링</strong></p>
<p><strong>계층 샘플링</strong><font size="2">stratified sampling</font>은 각 계층별로 적절한 샘플을 추측하는 기법이다.
이유는 계층별로 충분한 크기의 샘플이 포함되도록 지정해야 학습 과정에서 편향이 발생하지 않는다.
예를 들어, 특정 소득 구간에 포함된 샘플이 과하게 적거나 많으면 해당 계층의 중요도가
과소 혹은 과대 평가될 수 있다.</p>
<p>캘리포니아 데이터셋의 중간 소득을 대상으로하는 히스토그램을 보면
대부분 구역의 중간 소득이 1.5~6.0, 즉 15,000에서 60,000 달러 사이인 것을 알 수 있다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-08.png" width="400"></div><p>소득 구간을 아래 숫자들을 기준으로 5개로 구분한 다음에 계층 샘플링을 이용하여
훈련셋과 테스트셋을 구분할 수 있다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>구간</p></th>
<th class="head text-left"><p>범위</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-left"><p>0 ~ 1.5</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-left"><p>1.5 ~ 3.0</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-left"><p>3.0 ~ 4.5</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4</p></td>
<td class="text-left"><p>4.5 ~ 6.0</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5</p></td>
<td class="text-left"><p>6.0 ~</p></td>
</tr>
</tbody>
</table>
<p>5 개의 구간으로 구분한 결과는 다음과 같다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-08a.png" width="400"></div><p>무작위 추출 방식과는 달리 계층별 샘플의 비율을 거의 동일하게 유지함을 확인할 수 있다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>소득 구간</p></th>
<th class="head text-right"><p>전체(%)</p></th>
<th class="head text-right"><p>계층 샘플링(%)</p></th>
<th class="head text-right"><p>무작위 샘플링(%)</p></th>
<th class="head text-right"><p>계층 샘플링 오류율</p></th>
<th class="head text-right"><p>무작위 샘플링 오류율(%)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-right"><p>3.98</p></td>
<td class="text-right"><p>4.00</p></td>
<td class="text-right"><p>4.24</p></td>
<td class="text-right"><p>0.36</p></td>
<td class="text-right"><p>6.45</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-right"><p>31.88</p></td>
<td class="text-right"><p>31.88</p></td>
<td class="text-right"><p>30.74</p></td>
<td class="text-right"><p>-0.02</p></td>
<td class="text-right"><p>-3.59</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-right"><p>35.06</p></td>
<td class="text-right"><p>35.05</p></td>
<td class="text-right"><p>34.52</p></td>
<td class="text-right"><p>-0.01</p></td>
<td class="text-right"><p>-1.53</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4</p></td>
<td class="text-right"><p>17.63</p></td>
<td class="text-right"><p>17.64</p></td>
<td class="text-right"><p>18.41</p></td>
<td class="text-right"><p>0.03</p></td>
<td class="text-right"><p>4.42</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5</p></td>
<td class="text-right"><p>11.44</p></td>
<td class="text-right"><p>11.43</p></td>
<td class="text-right"><p>12.09</p></td>
<td class="text-right"><p>-0.08</p></td>
<td class="text-right"><p>5.63</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id9">
<h2><span class="section-number">2.4. </span>데이터 탐색과 시각화<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h2>
<p>테스트셋을 제외한 훈련셋에 대해서 시각화를 이용하여 데이터셋을 탐색한다.
테스트셋을 함께 탐색하면 미래의 데이터 특징을 미리 가정하는 데이터 스누핑 편향 오류를
범할 가능성이 높아진다.</p>
<section id="id10">
<h3><span class="section-number">2.4.1. </span>지리적 데이터 시각화<a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h3>
<p>경도와 위도 정보를 이용하여 구역을 산포도로 나타내면 인구의 밀집 정도를 확인할 수 있다.
예를 들어, 샌프란시스코의 Bay Area, LA, 샌디에고 등 유명 대도시의 특정 구역이 높은 인구 밀도를 갖는다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-09.png" width="500"></div><p>인구 밀도가 높은 유명 대도시의 특정 구역에 위치한
주택 가격이 높다는 일반적인 사실 또한 산포도록 확인할 수 있다.
산포도를 그릴 때 해당 구역의 중간 주택 가격을 색상으로,
인구밀도는 원의 크기로 활용한 결과는 다음과 같다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-11.png" width="500"></div></section>
<section id="id11">
<h3><span class="section-number">2.4.2. </span>상관관계 조사<a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h3>
<p>중간 주택 가격 특성과 다른 특성 사이의 선형 상관관계를 나타내는 상관계수는 다음과 같다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">median_house_value</span>    <span class="mf">1.000000</span>
<span class="n">median_income</span>         <span class="mf">0.688380</span>
<span class="n">total_rooms</span>           <span class="mf">0.137455</span>
<span class="n">housing_median_age</span>    <span class="mf">0.102175</span>
<span class="n">households</span>            <span class="mf">0.071426</span>
<span class="n">total_bedrooms</span>        <span class="mf">0.054635</span>
<span class="n">population</span>           <span class="o">-</span><span class="mf">0.020153</span>
<span class="n">longitude</span>            <span class="o">-</span><span class="mf">0.050859</span>
<span class="n">latitude</span>             <span class="o">-</span><span class="mf">0.139584</span>
</pre></div>
</div>
<p><strong>상관계수의 특징</strong></p>
<p>상관계수는 -1에서 1 사이의 값으로 표현된다.</p>
<ul class="simple">
<li><p>1에 가까울 수록: 강한 양의 선형 상관관계</p></li>
<li><p>-1에 가까울 수록: 강한 음의 선형 상관관계</p></li>
<li><p>0에 가까울 수록: 매우 약한 선형 상관관계</p></li>
</ul>
<div class="warning admonition">
<p class="admonition-title">상관계수와 상관관계</p>
<p>상관계수가 0이라는 것은 선형 상관관계가 없다는 의미이지 서로 아무런 상관관계가 없다는 말이 아니다.
또한 선형계수가 1이라 하더라도 두 특성이 1대 1로 의존한다는 의미도 아님을
아래 그림이 잘 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-14.png" width="400"></div>
<p>&lt;그림 출처: <a class="reference external" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">위키백과</a>&gt;</p>
</div>
<p>중간 주택 가격과 중간 소득의 상관계수가 0.68로 가장 높다.
이는 중간 소득이 올라가면 중간 주택 가격도 상승하는 경향이 있음을 의미한다.
하지만 아래 산점도의 점들이 너무 넓게 퍼져 있어서 완벽한 선형관계와는 거리가 멀다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-13.png" width="400"></div><p>위 산점도를 볼 때 다음 사항들에 주의해야 한다.</p>
<ul class="simple">
<li><p>50만 달러에서 보이는 수평선은 가격을 제한한 결과로 보여진다.</p></li>
<li><p>45만, 35만, 28만, 그 아래 정도에서도 수평선이 존재하는데 이유는 알려지지 않았다.</p></li>
<li><p>이처럼 이상한 성질을 모델이 형태를 학습하지 못하도록 해당 구역을 제거하는 것이
일반적으로 좋다. 하지만 여기서는 그대로 두고 사용한다.</p></li>
</ul>
<p>경우에 따라 기존의 특성을 조합해서 새로운 특성을 활용할 수도 있다.
예를 들어 구역별 방의 총 개수와 침실의 총 개수 대신 아래 특성이 보다 유용해 보인다.</p>
<ul class="simple">
<li><p>가구당 방 개수(<code class="docutils literal notranslate"><span class="pre">rooms_for_house</span></code>)</p></li>
<li><p>방 하나당 침실 개수(<code class="docutils literal notranslate"><span class="pre">bedrooms_ratio</span></code>)</p></li>
<li><p>가구당 인원(<code class="docutils literal notranslate"><span class="pre">people_perhouse</span></code>)</p></li>
</ul>
<p>실제로 세 특성을 새로 추가한 다음에 상관계수를 확인하면
방 하나당 침실 개수와 중간 주택 가격 사이의 선형 상관관계가
중간 소득을 제외한 기존의 다른 특성들에 비해 높게 나타난다.</p>
</section>
</section>
<section id="id12">
<h2><span class="section-number">2.5. </span>데이터 준비<a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h2>
<p>머신러닝 모델 훈련에 사용되는 알고리즘을 이용하려면
적재된 데이터셋을 데이터 정제와 전처리 과정을 수행해서
바로 모델 훈련에 사용될 수 있도록 해야 한다.
또한 모든 과정을 자동화할 수 있어야 한다.</p>
<p>정제와 전처리 모든 과정을
<strong>파이프라인</strong><font size="2">pipeline</font>으로
자동화해서 언제든지 재활용하는 방식을 상세히 설명한다.</p>
<p><strong>입력 데이터셋과 타깃 데이터셋</strong></p>
<p>계층 샘플링으로 얻어진  훈련셋 <code class="docutils literal notranslate"><span class="pre">strat_train_set</span></code> 을
다시 입력 데이터셋 과 타깃 데이터셋으로 구분한다.</p>
<ul>
<li><p>입력 데이터셋: 중간 주택 가격 특성이 제거된 훈련셋</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing</span> <span class="o">=</span> <span class="n">strat_train_set</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>타깃 데이터셋: 중간 주택 가격 특성으로만 구성된 훈련셋</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">housing_labels</span> <span class="o">=</span> <span class="n">strat_train_set</span><span class="p">[</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
<section id="id13">
<h3><span class="section-number">2.5.1. </span>데이터 정제와 전처리<a class="headerlink" href="#id13" title="Permalink to this heading">#</a></h3>
<p>데이터 정제는 결측치 처리, 이상치 및 노이즈 데이터 제거 등을 의미한다.
캘리포니아 주택 가격 데이터셋은 구역별 방 총 개수(<code class="docutils literal notranslate"><span class="pre">total_rooms</span></code>) 특성에서
결측치가 일부 포함되어 있지만 이상치 또는 노이즈 데이터는 없다.</p>
<p>데이터 전처리<font size='2'>preprocessing</font>는 수치형 특성과 범주형 특성을 구분하여 수행한다.</p>
<ul class="simple">
<li><p>범주형 특성 전처리 과정</p>
<ul>
<li><p>원-핫-인코딩</p></li>
</ul>
</li>
<li><p>수치형 특성에 대한 전처리</p>
<ul>
<li><p>특성 크기 조정</p></li>
<li><p>특성 조합</p></li>
</ul>
</li>
</ul>
<p>데이터 정제와 전처리의 모든 과정은 데이터셋에 포함된 샘플을 한꺼번에 변환한다.
따라서 모든 변환 과정을 자동화는
<strong>파이프라인</strong><font size="2">pipeline</font> 기법을 활용할 수 있어야 한다.</p>
<p><strong>파이프라인</strong></p>
<ul class="simple">
<li><p>여러 사이킷런 API를 묶어 순차적으로 처리하는 사이킷런 API</p></li>
<li><p>여러 과정을 한 번에 엮어서 수행하도록 하는 도구</p></li>
</ul>
<p><strong>사이킷런 API 활용</strong></p>
<p>사이킷런<font size="2">Scikit-Learn</font>이 제공하는
모든 API는 간단하게 합성할 수 있다.
이점을 이해하려면 먼저 사이킷런이 제공하는 API의 유형을 구분해야 한다.
사이킷런의 API는 크게 세 종류의 API로 나뉜다.</p>
<ul class="simple">
<li><p>추정기<font size="2">estimator</font>: <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 제공하는 클래스의 객체</p>
<ul>
<li><p>주어진 데이터로부터 필요한 정보인 파라미터<font size='2'>parameter</font> 계산</p></li>
<li><p>계산된 파라미터를 객체 내부의 속성<font size='2'>attribute</font>으로 저장</p></li>
<li><p>반환값: 계산된 파라미터를 속성으로 갖는 객체</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>변환기<font size="2">transformer</font></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 가 계산한 값을 이용하여 데이터셋을 변환하는 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드 지원.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드와 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 연속해서 호출하는 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드 지원.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>예측기<font size="2">predictor</font></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 가 계산한 값을 이용하여 예측에 활용하는 <code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드 지원.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">predict()</span></code> 메서드가 예측한 값의 성능을 측정하는 <code class="docutils literal notranslate"><span class="pre">score()</span></code> 메서드 지원.</p></li>
<li><p>일부 예측기는 예측값의 신뢰도를 평가하는 기능도 제공</p></li>
</ul>
</li>
</ul>
</section>
<section id="id14">
<h3><span class="section-number">2.5.2. </span>데이터 정제<a class="headerlink" href="#id14" title="Permalink to this heading">#</a></h3>
<p>입력 데이터셋의 <code class="docutils literal notranslate"><span class="pre">total_bedrooms</span></code> 특성에 168개 구역의 값이 <code class="docutils literal notranslate"><span class="pre">NaN</span></code>(Not a Number)로 표시되어 있다.
즉, 일부 구역에 대한 방의 총 개수 정보가 누락되었다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/null-value01.png" width="800"></div><p>머신러닝 모델은 결측치가 있는 데이터셋을 잘 활용하지 못한다.
따라서 아래 방법 중 하나를 선택해서 데이터를 정제해야 한다.</p>
<ul class="simple">
<li><p>방법 1: 해당 샘플(구역) 제거</p></li>
<li><p>방법 2: 해당 특성 삭제</p></li>
<li><p>방법 3: 평균값, 중앙값, 0, 주변에 위치한 값 등 특정 값으로 채우기.</p></li>
</ul>
<p>여기서는 중앙값으로 채우는 방법 3을 사이킷런의 <code class="docutils literal notranslate"><span class="pre">SimpleImputer</span></code> 변환기를 이용하여 적용한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/null-value02.png" width="800"></div></section>
<section id="id15">
<h3><span class="section-number">2.5.3. </span>범주형 특성 전처리: 원-핫 인코딩<a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h3>
<p>해안 근접도(<code class="docutils literal notranslate"><span class="pre">ocean_proximity</span></code>)는 수가 아닌 5 개의 범주를 나타내는 문자열, 즉 텍스트 데이터를 값으로 사용한다.
그런데 머신러닝 모델은 일반적으로 텍스트 데이터를 처리하지 못한다.</p>
<p>가장 단순한 해결책으로 5 개의 범주를 정수로 변환할 수 있다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>범주</p></th>
<th class="head text-center"><p>숫자</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>&lt;1H OCEAN</p></td>
<td class="text-center"><p>0</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>INLAND</p></td>
<td class="text-center"><p>1</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>ISLAND</p></td>
<td class="text-center"><p>2</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>NEAR BAY</p></td>
<td class="text-center"><p>3</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>NEAR OCEAN</p></td>
<td class="text-center"><p>4</p></td>
</tr>
</tbody>
</table>
<p>하지만 이 방식은 수의 크기 특성을 모델이 활용할 수 있기에 위험하다.
예를 들어 4에 해당하는 바닷가 근처(<code class="docutils literal notranslate"><span class="pre">NEAR</span> <span class="pre">OCEAN</span></code>)에 위치한 주택이 가장 비쌀 것으로
모델이 훈련될 가능성이 높다.</p>
<p>범주형 특성을 수치화하는 가장 일반적인 방식은
<strong>원-핫 인코딩</strong><font size="2">one-hot encoding</font>이다.
원-핫 인코딩은 수치화된 범주들 사이의 크기 비교를 피하기 위해
더미<font size="2">dummy</font> 특성을 활용한다.</p>
<div class="info admonition">
<p class="admonition-title">더미 특성</p>
<p>컴퓨터 분야에서 더미, 영어로 dummy는 의미없는 변수, 특성, 영역, 회로 등을 가리킨다.
여기서는 한 구역의 해안 근접도를 지정할 때 굳이 필요 없는 다른 값도 함께 고려한다는 의미로
더미 특성을 사용한다.</p>
</div>
<p>원-핫 인코딩을 적용하면 해안 근접도 특성을 삭제하고 대신 다섯 개의 범주 전부를
새로운 특성으로 추가한다.
또한 다섯 개의 특성에 사용되는 값은 다음 방식으로 지정된다.</p>
<ul class="simple">
<li><p>해당 카테고리의 특성값: 1</p></li>
<li><p>나머지 카테고리의 특성값: 0</p></li>
</ul>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">INLAND</span></code>를 해안 근접도 특성값으로 갖던 샘플은 다음 모양의 특성값을 갖게 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">OneHotEncoder</span></code> 변환기가 원-핫-인코딩을 지원하며
해안 근접도를 변환한 결과는 아래 모양을 갖는다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/one_hot01.png" width="800"></div></section>
<section id="id16">
<h3><span class="section-number">2.5.4. </span>수치형 특성 전처리: 크기 조정<a class="headerlink" href="#id16" title="Permalink to this heading">#</a></h3>
<p>머신러닝 알고리즘은 입력 데이터셋의 특성값들의
<strong>크기</strong><font size="2">scale</font>가 다르면 제대로 작동하지 않는다.
따라서 모든 특성의 크기를 통일하는 <strong>크기 조정</strong><font size="2">scaling</font>이 요구된다.</p>
<p>크기 조정은 보통 아래 두 가지 방식을 사용한다.</p>
<ul class="simple">
<li><p>min-max 크기 조정(정규화)</p></li>
<li><p>표준화</p></li>
</ul>
<p><strong>min-max 크기 조정(정규화)</strong></p>
<p><strong>정규화</strong><font size='2'>normalization</font>라고도 불리는 min-max 크기 조정은
아래 식을 이용하여 모든 특성값을 0에서 1 사이의 값으로 변환한다.
단, <span class="math notranslate nohighlight">\(max\)</span> 와 <span class="math notranslate nohighlight">\(min\)</span> 은 각각 특성값들의 최댓값과 최솟값을 가리킨다.</p>
<div class="math notranslate nohighlight">
\[
\frac{x-min}{max-min}
\]</div>
<p>min-max 크기 조정은 이상치에 매우 민감하다.
예를 들어 이상치가 매우 크면 분모가 분자에 비해 훨씬 크게 되어 변환된 값이 0 근처에 몰리게 된다.
사이킷런의 <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> 변환기가 min-max 크기 조정을 지원한다.</p>
<p><strong>표준화<font size='2'>standardization</font></strong></p>
<p>아래식을 이용하여 특성값을 변환한다.
단, <span class="math notranslate nohighlight">\(\mu\)</span> 와 <span class="math notranslate nohighlight">\(\sigma\)</span> 는 각각 특성값들의 평균값과 표준편차를 가리킨다.</p>
<div class="math notranslate nohighlight">
\[
\frac{x-\mu}{\sigma}
\]</div>
<p>변환된 데이터셋은 평균값은 0, 표준편차는 1인 분포를 따르며, 이상치에 상대적으로 덜 영향을 받는다.
여기서는 사이킷런의 <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> 변환기를 이용하여 표준화를 적용한다.</p>
</section>
<section id="id17">
<h3><span class="section-number">2.5.5. </span>사용자 정의 변환기<a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h3>
<p>데이터 준비 과정에서 경우에 따라 사용자가 직접 변환기를 구현해야할 필요가 있다.</p>
<section id="functiontransformer">
<h4><span class="section-number">2.5.5.1. </span><code class="docutils literal notranslate"><span class="pre">FunctionTransformer</span></code> 변환기<a class="headerlink" href="#functiontransformer" title="Permalink to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 먼저 사용하지 않고 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 바로 적용해도 되는
변환기는 <code class="docutils literal notranslate"><span class="pre">FunctionTransformer</span></code> 객체를 활용하여 생성할 수 있다.</p>
<p><strong>로그 함수 적용 변환기</strong></p>
<p>데이터셋이 두터운 꼬리 분포를 따르는 경우,
즉 히스토그램이 지나치게 한쪽으로 편향된 경우
크기 조정을 적용하기 전에 먼저
로그 함수를 적용하여 어느 정도 좌우 균형이 잡힌 분포로 변환하는 게 좋다.
아래 그림은 인구에 로그함수를 적용할 때 분포가 보다 균형잡히는 것을 잘 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-log_app.jpg" width="600"></div><p>두터운 꼬리 분포를 갖는 데이터셋에 로그 함수를 적용하고자 하면 아래 변환기를 사용하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">inverse_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>비율 계산 변환기</strong></p>
<p>두 개의 특성 사이의 비율을 계산하여 새로운 특성을 생성하는 변환기 또한
<code class="docutils literal notranslate"><span class="pre">FunctionTransformer</span></code>를 활용할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">FunctionTransformer</span><span class="p">(</span><span class="k">lambda</span> <span class="n">X</span><span class="p">:</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>비율 계산 변환기를 이용하여 아래 특성을 새롭게 생성할 수 있다.</p>
<ul class="simple">
<li><p>가구당 방 개수(rooms for household)</p></li>
<li><p>방 하나당 침실 개수(bedrooms for room)</p></li>
<li><p>가구당 인원(population per household)</p></li>
</ul>
</section>
<section id="id18">
<h4><span class="section-number">2.5.5.2. </span>사용자 정의 변환기 클래스 선언: 군집 변환기<a class="headerlink" href="#id18" title="Permalink to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">SimpleImputer</span></code> 변환기의 경우처럼
먼저 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 이용하여 평균값, 중앙값 등을 확인한 다음에
<code class="docutils literal notranslate"><span class="pre">transform()</span></code> 메서드를 적용할 수 있는 변환기는 클래스를 직접 선언해야 한다.
이때 사이킷런의 다른 변환기와 호환이 되도록 하기 위해
<code class="docutils literal notranslate"><span class="pre">fit()</span></code> 과 <code class="docutils literal notranslate"><span class="pre">transform()</span></code> 등 다양한 메서드를 모두 구현해야 한다.</p>
<p>예를 들어, 캘리포니아 주 2만 여개의 구역을 서로 가깝게 위치한 구역들로 묶어
총 10개의 군집으로 구분하는 변환기 클래스를 선언한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClusterSimilarity</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmeans_</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmeans_</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># 항상 self 반환</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rbf_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmeans_</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_feature_names_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> similarity&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="unsupervised_learning.html#ch-unsupervisedlearning"><span class="std std-numref">9장</span></a> 비지도 학습에서 위 코드를 자세히 설명한다.
여기서는 다음 두 가지만을 기억한다.</p>
<p>첫째, 변환기를 선언할 때 <code class="docutils literal notranslate"><span class="pre">BaseEstimator</span></code>와 <code class="docutils literal notranslate"><span class="pre">TransformerMixin</span></code> 두 개의 클래스를 상속해야 한다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/custom-transformer.png" width="350"></div>
<br>
<p>둘째, <code class="docutils literal notranslate"><span class="pre">get_feature_names_out()</span></code> 메서드를 재정의해서 변환기에 의해 새로 생성된 특성들의 이름을
지정하는 방식을 설정해야 한다.</p>
<div class="info admonition">
<p class="admonition-title">하이퍼파라미터와 변환기 클래스 상속</p>
<p>사이킷런 클래스의 <strong>하이퍼파라미터</strong><font size='2'>hyperparameter</font>는
해당 클래스의 객체를 생성할 때 사용되는 값을 가리킨다.
반면에 <strong>파라미터</strong><font size='2'>parameter</font>는
<code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드가 데이터를 이용하여 계산하는 값을 가리킨다.
추정기, 변환기, 예측기는 각각의 역할에 맞는 파라미터를 계산한다.</p>
<p>사이킷런의 모든 클래스는 적절한
<strong>하이퍼파라미터</strong><font size="2">hyperparameter</font>로 초기화되어 있으며
데이터 변환과 값 예측에 필요한 모든 파라미터를 효율적으로 관리한다.</p>
<p>변환기 클래스를 선언할 때 <code class="docutils literal notranslate"><span class="pre">BaseEstimator</span></code> 클래스를 상속하면
하이퍼파라미터를 조정을 자동화할 때 필요한 <code class="docutils literal notranslate"><span class="pre">get_params()</span></code>, <code class="docutils literal notranslate"><span class="pre">set_params()</span></code> 두 메서드를
함께 상속한다.</p>
<p>반면에 <code class="docutils literal notranslate"><span class="pre">TransformerMixin</span></code> 클래스를 상속하는 이유 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code>
메서드가 자동으로 상속되기 때문이다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ClusterSimilarity</span></code> 변환기를 이용하여 얻어진 군집 특성을 이용하면
아래 그림과 같은 결과를 얻을 수 있다.</p>
<ul class="simple">
<li><p>모든 구역을 10개의 군집으로 분류한다.</p></li>
<li><p>🗙는 각 군집의 중심 구역을 나타낸다.</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/homl02-cluster.jpg" width="550"></div></section>
</section>
<section id="id19">
<h3><span class="section-number">2.5.6. </span>변환 파이프라인<a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h3>
<p>모든 전처리 단계가 정확한 순서대로 진행되어야 한다.
이를 위해 사이킷런의 <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> 클래스를 이용하여 여러 변환기를 순서대로
실행하는 변환기 파이프라인을 활용한다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> 클래스 활용</strong></p>
<p>예를 들어, 수치형 특성을 대상으로 결측치를 중앙값으로 채우는 정제와
표준화를 연속적으로 실행하는 파이프라인은 다음과 같이 정의한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s2">&quot;impute&quot;</span><span class="p">,</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)),</span>
                         <span class="p">(</span><span class="s2">&quot;standardize&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">())])</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> 객체를 생성할 때 사용되는 인자는 이름과 추정기로 이루어진 쌍들의 리스트이다.</p></li>
<li><p>마지막 추정기를 제외한 나머지 추정기는 모두 변환기다.
즉, 마지막 추정기는 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드만 지원해도 되지만
나머지는 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드가 지원되는 변환기어야 한다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pipeline.fit()</span></code> 를 호출하면
마지막 변환기 까지는 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메소드가 연속적으로 호출되고
마지막 변환기의 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드 최종 호출된다.</p></li>
<li><p>파이프라인으로 정의된 추정기의 유형은 마지막 추정기의 유형과 동일하다.
따라서 <code class="docutils literal notranslate"><span class="pre">num_pipeline</span></code> 은 변환기다.</p></li>
</ul>
<p><strong><code class="docutils literal notranslate"><span class="pre">make_pipeline()</span></code> 함수 활용</strong></p>
<p>파이프라인에 포함되는 변환기의 이름이 중요하지 않다면 <code class="docutils literal notranslate"><span class="pre">make_pipeline()</span></code> 함수를 이용하여
<code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> 객체를 생성할 수 있다. 이름은 자동으로 지정된다.</p>
<p>위 파이프라인과 동일한 파이프라인 객체를 다음과 같이 생성할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">),</span> 
              <span class="n">StandardScaler</span><span class="p">())</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">ColumnTransformer</span></code> 클래스 활용</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">ColumnTransformer</span></code> 클래스는 특성별로 전처리를 지정할 수 있다.
이 기능을 이용하여 수치형 특성과 범주형 특성을 구분해서
전처리하는 통합 파이프라인을 다음과 같이 구성할 수 있다.</p>
<ul class="simple">
<li><p>수치형 특성: <code class="docutils literal notranslate"><span class="pre">num_pipeline</span></code> 변환기</p></li>
<li><p>범주형 특성: <code class="docutils literal notranslate"><span class="pre">OneHotEncoder</span></code> 변환기</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_attribs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;housing_median_age&quot;</span><span class="p">,</span> <span class="s2">&quot;total_rooms&quot;</span><span class="p">,</span>
               <span class="s2">&quot;total_bedrooms&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;households&quot;</span><span class="p">,</span> <span class="s2">&quot;median_income&quot;</span><span class="p">]</span>
<span class="n">cat_attribs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ocean_proximity&quot;</span><span class="p">]</span>

<span class="n">cat_pipeline</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
    <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">),</span>
    <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">handle_unknown</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">))</span>

<span class="n">preprocessing</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">([</span>
    <span class="p">(</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="n">num_pipeline</span><span class="p">,</span> <span class="n">num_attribs</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">cat_pipeline</span><span class="p">,</span> <span class="n">cat_attribs</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">make_column_selector()</span></code> 함수 활용</strong></p>
<p>파이프라인에 포함되는 각 변환기를 적용할 특성을 일일이 나열하는 일이 어려울 수 있다.
이때 지정된 자료형을 사용하는 특성들만을 뽑아주는 <code class="docutils literal notranslate"><span class="pre">make_column_selector()</span></code> 함수를
유용하게 활용할 수 있다.</p>
<p>위 <code class="docutils literal notranslate"><span class="pre">preprocessing</span></code> 변환기를 아래와 같이 정의할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">preprocessing</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">([</span>
    <span class="p">(</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="n">num_pipeline</span><span class="p">,</span> <span class="n">make_column_selector</span><span class="p">(</span><span class="n">dtype_include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">cat_pipeline</span><span class="p">,</span> <span class="n">make_column_selector</span><span class="p">(</span><span class="n">dtype_include</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">make_column_transformer()</span></code> 함수 활용</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">ColumnTransformer</span></code> 파이프라인에 포함되는 변환기의 이름이 중요하지 않다면
<code class="docutils literal notranslate"><span class="pre">make_column_transformer()</span></code> 함수를 이용할 수 있으며,
<code class="docutils literal notranslate"><span class="pre">make_pipeline()</span></code> 함수와 유사하게 작동한다.</p>
<p>위 <code class="docutils literal notranslate"><span class="pre">preprocessing</span></code> 변환기를 아래와 같이 정의할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">preprocessing</span> <span class="o">=</span> <span class="n">make_column_transformer</span><span class="p">(</span>
    <span class="p">(</span><span class="n">num_pipeline</span><span class="p">,</span> <span class="n">make_column_selector</span><span class="p">(</span><span class="n">dtype_include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">cat_pipeline</span><span class="p">,</span> <span class="n">make_column_selector</span><span class="p">(</span><span class="n">dtype_include</span><span class="o">=</span><span class="nb">object</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id20">
<h3><span class="section-number">2.5.7. </span>캘리포니아 데이터셋 변환 파이프라인<a class="headerlink" href="#id20" title="Permalink to this heading">#</a></h3>
<p>다음 변환기를 모아 캘리포니아 데이터셋 전용 변환 파이프라인을 생성할 수 있다.</p>
<p>(1) 비율 변환기</p>
<p>가구당 방 개수, 방 하나당 침실 개수, 가구당 인원 등
비율을 사용하는 특성을 새로 추가할 때 사용되는 변화기를 생성하는 함수를 정의한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">column_ratio</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1"># 1번 특성에 대한 0번 특성의 비율율</span>

<span class="k">def</span> <span class="nf">ratio_name</span><span class="p">(</span><span class="n">function_transformer</span><span class="p">,</span> <span class="n">feature_names_in</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;ratio&quot;</span><span class="p">]</span>  <span class="c1"># 새로 생성되는 특성 이름에 추가</span>

<span class="k">def</span> <span class="nf">ratio_pipeline</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">make_pipeline</span><span class="p">(</span>
        <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">),</span>
        <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">column_ratio</span><span class="p">,</span> <span class="n">feature_names_out</span><span class="o">=</span><span class="n">ratio_name</span><span class="p">),</span>
        <span class="n">StandardScaler</span><span class="p">())</span>
</pre></div>
</div>
<p>(2) 로그 변환기</p>
<p>데이터 분포가 두터운 꼬리를 갖는 특성을 대상으로 로그 함수를 적용하는 변환기를 지정한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">log_pipeline</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
    <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">),</span>
    <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">feature_names_out</span><span class="o">=</span><span class="s2">&quot;one-to-one&quot;</span><span class="p">),</span>
    <span class="n">StandardScaler</span><span class="p">())</span>
</pre></div>
</div>
<p>(3) 군집 변환기</p>
<p>구역의 위도와 경도를 이용하여 구역들의 군집 정보를 새로운 특성으로 추가하는 변환기를 지정한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cluster_simil</span> <span class="o">=</span> <span class="n">ClusterSimilarity</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>(4) 기본 변환기</p>
<p>특별한 변환이 필요 없는 경우에도 기본적으로 결측치 문제 해결과 스케일을 조정하는 변환기를 사용한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">default_num_pipeline</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">),</span>
                                     <span class="n">StandardScaler</span><span class="p">())</span>
</pre></div>
</div>
<p><strong>종합</strong></p>
<p>앞서 언급된 모든 변환기를 특성별로 알아서 처리하는 변환기는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">remainder=default_num_pipeline</span></code>: 언급되지 않은 특성을 처리하는 변환기를 지정한다.
삭제를 의미하는 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 이 기본값이며 이외에 <code class="docutils literal notranslate"><span class="pre">passthrough</span></code> 는 변환하지 않는 것을 의미한다.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">preprocessing</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">([</span>
        <span class="p">(</span><span class="s2">&quot;bedrooms&quot;</span><span class="p">,</span> <span class="n">ratio_pipeline</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;total_bedrooms&quot;</span><span class="p">,</span> <span class="s2">&quot;total_rooms&quot;</span><span class="p">]),</span>    <span class="c1"># 방당 침실 수</span>
        <span class="p">(</span><span class="s2">&quot;rooms_per_house&quot;</span><span class="p">,</span> <span class="n">ratio_pipeline</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;total_rooms&quot;</span><span class="p">,</span> <span class="s2">&quot;households&quot;</span><span class="p">]),</span> <span class="c1"># 가구당 침실 수</span>
        <span class="p">(</span><span class="s2">&quot;people_per_house&quot;</span><span class="p">,</span> <span class="n">ratio_pipeline</span><span class="p">(),</span> <span class="p">[</span><span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;households&quot;</span><span class="p">]),</span> <span class="c1"># 가구당 인원</span>
        <span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">log_pipeline</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;total_bedrooms&quot;</span><span class="p">,</span> <span class="s2">&quot;total_rooms&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="c1"># 로그 변환</span>
                               <span class="s2">&quot;households&quot;</span><span class="p">,</span> <span class="s2">&quot;median_income&quot;</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;geo&quot;</span><span class="p">,</span> <span class="n">cluster_simil</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">]),</span>                    <span class="c1"># 구역별 군집 정보</span>
        <span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">cat_pipeline</span><span class="p">,</span> <span class="n">make_column_selector</span><span class="p">(</span><span class="n">dtype_include</span><span class="o">=</span><span class="nb">object</span><span class="p">)),</span>    <span class="c1"># 범주형 특성 전처리</span>
    <span class="p">],</span>
    <span class="n">remainder</span><span class="o">=</span><span class="n">default_num_pipeline</span><span class="p">)</span>          <span class="c1"># 남은 특성인 중간 주택 년수(housing_median_age) 대상</span>
</pre></div>
</div>
<div class="info admonition">
<p class="admonition-title">타깃 데이터셋과 전처리</p>
<p>데이터 준비는 기본적으로 입력 데이터셋만을 대상으로 <strong>정제</strong><font size="2">cleaning</font>와
<strong>전처리</strong><font size="2">preprocessing</font> 단계로 실행된다.
타깃 데이터셋은 결측치가 없는 경우라면 일반적으로 정제와 전처리 대상이 아니지만
경우에 따라 변환이 요구될 수 있다.</p>
<p>예를 들어, 타깃 데이터셋의 두터운 꼬리 분포를 따르는 경우
로그 함수를 적용하여 데이터의 분포가 보다 균형잡히도록 하는 것이 권장된다.
하지만 이런 경우 예측값을 계산할 때 원래의 척도로 되돌려야 하며
이를 위해 대부분의 사이킷런 변환기가 지원하는 <code class="docutils literal notranslate"><span class="pre">inverse_transorm()</span></code> 메서드를 활용할 수 있다.</p>
</div>
</section>
</section>
<section id="id21">
<h2><span class="section-number">2.6. </span>모델 선택과 훈련<a class="headerlink" href="#id21" title="Permalink to this heading">#</a></h2>
<p>훈련셋 준비가 완료된 상황에서 모델을 선택하고 훈련시키는 일이 남아 있다.</p>
<p>사이킷런이 제공하는 예측기 모델을 사용하면 훈련은 기본적으로 간단하게 진행된다.
여기서는 사이킷런이 제공하는 다양한 모델의 사용법과 차이점을 간단하게 살펴본다.
각 모델의 자세한 특징과 상세 설명은 앞으로 차차 이루어질 것이다.</p>
<div class="info admonition">
<p class="admonition-title">전처리 포함 파이프라인 모델</p>
<p>소개되는 모든 모델은 앞서 설명한 전처리 과정과 함께 하나의 파이프라인으로 묶여서 정의된다.
따라서 테스트셋과 미래의 새로운 입력 데이터에 대해서도 전처리를 별도로 신경쓸 필요가 없다.</p>
</div>
<section id="id22">
<h3><span class="section-number">2.6.1. </span>모델 훈련과 평가<a class="headerlink" href="#id22" title="Permalink to this heading">#</a></h3>
<p><strong>선형 회귀 모델 (<a class="reference internal" href="training_models.html#ch-trainingmodels"><span class="std std-numref">4장</span></a>)</strong></p>
<ul>
<li><p>훈련 및 예측</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="n">lin_reg</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">preprocessing</span><span class="p">,</span> <span class="n">LinearRegression</span><span class="p">())</span>
<span class="n">lin_reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
<span class="n">lin_reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">housing</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul>
<li><p>RMSE(평균 제곱근 오차)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lin_rmse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">housing_labels</span><span class="p">,</span> <span class="n">housing_predictions</span><span class="p">,</span>
                              <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<ul class="simple">
<li><p>훈련 결과</p>
<ul>
<li><p>RMSE(<code class="docutils literal notranslate"><span class="pre">lin_rmse</span></code>)가 68687.89 정도로 별로 좋지 않다.</p></li>
<li><p>훈련된 모델이 훈련셋에 <strong>과소적합</strong> 되었다.</p></li>
<li><p>보다 좋은 특성을 찾거나 더 강력한 모델을 적용해야 한다.</p></li>
</ul>
</li>
</ul>
<p><strong>결정트리 회귀 모델 (<a class="reference internal" href="decision_trees.html#ch-decisiontrees"><span class="std std-numref">6장</span></a>)</strong></p>
<p>결정트리 회귀 모델은 데이터에서 복잡한 비선형 관계를 학습할 때 사용한다.</p>
<ul class="simple">
<li><p>훈련 및 예측</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span>

<span class="n">tree_reg</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">preprocessing</span><span class="p">,</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">))</span>
<span class="n">tree_reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
<span class="n">housing_predictions</span> <span class="o">=</span> <span class="n">tree_reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">housing</span><span class="p">)</span>

<span class="n">tree_rmse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">housing_labels</span><span class="p">,</span> <span class="n">housing_predictions</span><span class="p">,</span>
                              <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>훈련 결과</p>
<ul>
<li><p>RMSE(<code class="docutils literal notranslate"><span class="pre">tree_rmse</span></code>)가 0으로 완벽해 보인다.</p></li>
<li><p>모델이 훈련셋에 심각하게 <strong>과대적합</strong> 되었음을 의미한다.</p></li>
<li><p>실전 상황에서 RMSE가 0이 되는 것은 불가능하다.</p></li>
<li><p>테스트셋에 대한 RMSE는 매우 높게 나온다.</p></li>
</ul>
</li>
</ul>
<p><strong>랜덤 포레스트 회귀 모델 (<a class="reference internal" href="ensemble_learning_random_forests.html#ch-ensemble"><span class="std std-numref">7장</span></a>)</strong></p>
<p><strong>랜덤 포레스트</strong><font size="2">random forest</font> 회귀 모델은
여러 개의 결정트리를 동시에 훈련시킨 후
각 모델의 예측값의 평균값 등을 이용하는 모델이다.
각 모델은 교차 검증처럼 서로 다른 훈련셋을 대상으로 학습한다.</p>
<p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">RandomForestRegressor</span></code> 모델은 기본값으로 100개의 결정트리를 동시에 훈련시킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span>

<span class="n">forest_reg</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">preprocessing</span><span class="p">,</span>
                           <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="id23">
<h3><span class="section-number">2.6.2. </span>교차 검증<a class="headerlink" href="#id23" title="Permalink to this heading">#</a></h3>
<p><strong>교차 검증</strong><font size="2">cross validation</font>을 이용하여
훈련중인 모델의 성능을 평가할 수 있다.</p>
<p><strong>k-겹 교차 검증</strong></p>
<ul class="simple">
<li><p>훈련셋을 <strong>폴드</strong><font size='2'>fold</font>라 불리는 k-개의 부분 집합으로 무작위로 분할한다.</p></li>
<li><p>모델을 총 k 번 훈련한다.</p>
<ul>
<li><p>매 훈련마나다 하나의 폴드를 선택하여 검증 데이터셋으로 지정.</p></li>
<li><p>나머지 (k-1) 개의 폴드를 대상으로 훈련</p></li>
<li><p>매 훈련이 끝날 때마다 선택된 검증 데이터셋을 이용하여 모델 평가</p></li>
<li><p>매번 다른 폴드 활용</p></li>
</ul>
</li>
<li><p>최종평가는 k-번 평가 결과의 평균값을 활용한다.</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/handson-ml3/master/jupyter-book/imgs/ch02/cross-val10.png" width="500"></div><p><strong>사이킷런의 <code class="docutils literal notranslate"><span class="pre">cross_val_score()</span></code> 함수</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">cross_val_score()</span></code> 함수는 k-겹 교차 검증 과정에서
훈련중인 모델의 성능을 측정한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">scoring</span></code> 키워드 인자로 훈련중인 모델의 성능을 측정하는 <strong>효용함수</strong>를 지정한다.
측정값은 높을 수록 좋은 성능으로 평가되기에 회귀 모델의 경우
일반적으로 RMSE의 음숫값을 사용한다.
이를 위해 <code class="docutils literal notranslate"><span class="pre">scoring=&quot;neg_mean_squared_error&quot;</span></code> 키워드 인자를 사용한다.
RMSE의 음숫값을 선택하는 이유는 RMSE가 낮을 수록 좋은 모델이기 때문이다.</p>
<p>아래 코드는 10 개의 폴드를 사용(<code class="docutils literal notranslate"><span class="pre">cv=10</span></code>)하여 결정트리 회귀 모델에 대한 교차 검증을 진행하고 평가한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="n">tree_rmses</span> <span class="o">=</span> <span class="o">-</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">tree_reg</span><span class="p">,</span> <span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">,</span>
                              <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_root_mean_squared_error&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>래덤 포레스트 모델에 대한 교차 검증을 적용하면 폴드 수에 비례하여 훈련 시간이 더 오래 걸린다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">forest_rmses</span> <span class="o">=</span> <span class="o">-</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">forest_reg</span><span class="p">,</span> <span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">,</span>
                                <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_root_mean_squared_error&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="info admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">scoring</span></code> 키워드 인자</p>
<p>교차 검증에 사용되는 모델의 종류에 따라 다양한 방식으로 모델의 성능을 측정할 수 있으며
<code class="docutils literal notranslate"><span class="pre">scoring</span></code> 키워드 인자를 이용하여 지정한다.
현재 사용 가능한 옵션값은 <a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html">사이킷런의 Metrics and Scoring 문서</a>에서
확인할 수 있다.</p>
</div>
</section>
</section>
<section id="id24">
<h2><span class="section-number">2.7. </span>모델 미세 조정<a class="headerlink" href="#id24" title="Permalink to this heading">#</a></h2>
<p>지금까지 살펴 본 모델 중에서 랜덤 포레스트 회귀 모델의 성능이 가장 좋았다.
이렇게 가능성이 높은 모델을 찾은 다음엔
모델의 세부 설정(하이퍼파라미터)을 조정하거나
성능이 좋은 모델 여러 개를 이용하여 모델의 성능을 최대한 끌어올린다.</p>
<p>이런 방식으로 잘 훈련된 모델의 성능을 좀 더 끌어 올리는 방법을
모델 <strong>미세 조정</strong><font size='2'>fine tuning</font>이라 한다.
모델 미세 조정은 보통 다음 세 가지 방식을 많이 사용한다.</p>
<ul class="simple">
<li><p>그리드 탐색</p></li>
<li><p>랜덤 탐색</p></li>
<li><p>앙상블 학습</p></li>
</ul>
<section id="id25">
<h3><span class="section-number">2.7.1. </span>그리드 탐색<a class="headerlink" href="#id25" title="Permalink to this heading">#</a></h3>
<p>지정된 하이퍼파라미터의 모든 조합에 대해 교차 검증을 진행하여 최적의 하이퍼파라미터 조합을 찾는다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> 클래스</strong></p>
<p>랜덤 포레스트 모델을 대상으로 그리드 탐색을 다음과 같이 실행하면
총 (3x3 + 2x3 = 15) 가지의 모델의 성능을 확인한다.
또한 3-겹 교차 검증(<code class="docutils literal notranslate"><span class="pre">cv=3</span></code>)을 진행하기에 모델 훈련을 총 45(=15x3)번 진행한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">full_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([</span>
    <span class="p">(</span><span class="s2">&quot;preprocessing&quot;</span><span class="p">,</span> <span class="n">preprocessing</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;random_forest&quot;</span><span class="p">,</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)),</span>
<span class="p">])</span>

<span class="n">param_grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;preprocessing__geo__n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
     <span class="s1">&#39;random_forest__max_features&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]},</span>
    <span class="p">{</span><span class="s1">&#39;preprocessing__geo__n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
     <span class="s1">&#39;random_forest__max_features&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]},</span>
<span class="p">]</span>

<span class="n">grid_search</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">full_pipeline</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                           <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_root_mean_squared_error&#39;</span><span class="p">)</span>

<span class="n">grid_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id26">
<h3><span class="section-number">2.7.2. </span>랜덤 탐색<a class="headerlink" href="#id26" title="Permalink to this heading">#</a></h3>
<p>그리드 탐색은 적은 수의 조합을 실험해볼 때만 유용하다.
반면에 하이퍼파라미터의 탐색 공간이 크면 랜덤 탐색이 보다 유용하다.
랜덤 탐색은 하이퍼라라미터 조합을 임의로 지정된 횟수만큼 진행한다.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">RandomizedSearchCV</span></code> 클래스</strong></p>
<p>아래 코드는 다음 두 하이퍼파라미터를 대상으로
10번(<code class="docutils literal notranslate"><span class="pre">n_iter=10</span></code>) 지정된 구간 내에서 무작위 선택을 진행한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">preprocessing__geo__n_clusters</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">random_forest__max_features</span></code></p></li>
</ul>
<p>또한 3-겹 교차검증(<code class="docutils literal notranslate"><span class="pre">cv=3</span></code>)을 진행하기에 모델 훈련을 총 30(=10x30)번 진행한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="n">param_distribs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;preprocessing__geo__n_clusters&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">50</span><span class="p">),</span>
                  <span class="s1">&#39;random_forest__max_features&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">20</span><span class="p">)}</span>

<span class="n">rnd_search</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
    <span class="n">full_pipeline</span><span class="p">,</span> <span class="n">param_distributions</span><span class="o">=</span><span class="n">param_distribs</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_root_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="n">rnd_search</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">housing</span><span class="p">,</span> <span class="n">housing_labels</span><span class="p">)</span>
</pre></div>
</div>
<div class="info admonition">
<p class="admonition-title">하이퍼파라리미터 무작위 선택</p>
<p>랜덤 탐색을 하려면 특정 옵션 변수갈들을 무작위로 선택해주는 확률분포 함수를 지정해야 한다.
앞서 랜덤 탐색에서 사용한 옵션 변수와 확률분포는 다음과 같이
이산 균등 분포를 사용하는 <code class="docutils literal notranslate"><span class="pre">randint()</span></code> 함수를 이용하였다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;preprocessing__geo__n_clusters&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="s1">&#39;random_forest__max_features&#39;</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>scipy는 이외에 다른 종류의 확률 분포 함수를 지원한다.
예를 들어, 지정된 구간에서의 부동소수점을 선택해야 한다면
연속 균등 분포 함수인 <code class="docutils literal notranslate"><span class="pre">scipy.stats.uniform(a,</span> <span class="pre">b)</span></code>를 이용할 수 있다.</p>
</div>
<div class="info admonition">
<p class="admonition-title">기타 모델 미세 조정 도구</p>
<p>다양한 방식의 모델 미세 조정에 대한 보다 자세한 정보는
<a class="reference external" href="https://neptune.ai/blog/best-tools-for-model-tuning-and-hyperparameter-optimization">Best Tools for Model Tuning and Hyperparameter Optimization</a>을 참고할 수 있다.</p>
</div>
<p><strong>앙상블 학습</strong></p>
<p>결정 트리 모델 하나보다 랜덤 포레스트처럼 여러 모델로 이루어진 모델이 보다 좋은 성능을 낼 수 있다.
또한 최고 성능을 보이는 서로 다른 개별 모델을 조합하면 보다 좋은 성능을 얻을 수 있다.
이렇게 성능이 좋은 여러 개의 모델을 함께 학습하여 예측값을 지정하는 방식을 앙상블 학습이라 하며,
<a class="reference internal" href="ensemble_learning_random_forests.html#ch-ensemble"><span class="std std-numref">7장</span></a>에서 자세히 다룬다.</p>
</section>
<section id="id27">
<h3><span class="section-number">2.7.3. </span>최적 모델 활용<a class="headerlink" href="#id27" title="Permalink to this heading">#</a></h3>
<p>그리드 탐색 또는 랜덤 탐색을 통해 얻어진 최적의 모델을 분석해서 문제에 대한 통찰을 얻을 수 있다.
예를 들어, 최적의 랜덤 포레스트 모델로부터 타깃 예측에 사용된 특성들의 상대적 중요도를 확인하여
중요하지 않은 특성을 제외할 수 있다.</p>
<p>캘리포니아 주택 가격 예측 모델의 경우 랜덤 탐색을 통해 찾아낸 최적의 모델에서
<code class="docutils literal notranslate"><span class="pre">feature_importances_</span></code>를 확인하면 다음 정보를 얻는다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">log__median_income</span></code> 특성이 가장 중요하다.</p></li>
<li><p>해안 근접도 특성 중에서 <code class="docutils literal notranslate"><span class="pre">INLAND</span></code> 특성만 중요하다.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">final_model</span> <span class="o">=</span> <span class="n">rnd_search</span><span class="o">.</span><span class="n">best_estimator_</span>                                 <span class="c1"># 최적 모델</span>
<span class="n">feature_importances</span> <span class="o">=</span> <span class="n">final_model</span><span class="p">[</span><span class="s2">&quot;random_forest&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">feature_importances_</span>  <span class="c1"># 특성뱔 상대적 중요도</span>

<span class="c1"># 중요도 내림차순 정렬</span>
<span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_importances</span><span class="p">,</span>
           <span class="n">final_model</span><span class="p">[</span><span class="s2">&quot;preprocessing&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">()),</span>
           <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="p">[(</span><span class="mf">0.18694559869103852</span><span class="p">,</span> <span class="s1">&#39;log__median_income&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0748194905715524</span><span class="p">,</span> <span class="s1">&#39;cat__ocean_proximity_INLAND&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.06926417748515576</span><span class="p">,</span> <span class="s1">&#39;bedrooms_ratio__bedrooms_ratio&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.05446998753775219</span><span class="p">,</span> <span class="s1">&#39;rooms_per_house__rooms_per_house&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.05262301809680712</span><span class="p">,</span> <span class="s1">&#39;people_per_house__people_per_house&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.03819415873915732</span><span class="p">,</span> <span class="s1">&#39;geo__Cluster 0 similarity&#39;</span><span class="p">),</span>
 <span class="p">[</span><span class="o">...</span><span class="p">]</span>
 <span class="p">(</span><span class="mf">0.00015061247730531558</span><span class="p">,</span> <span class="s1">&#39;cat__ocean_proximity_NEAR BAY&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">7.301686597099842e-05</span><span class="p">,</span> <span class="s1">&#39;cat__ocean_proximity_ISLAND&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p><strong>테스트셋 활용 최종 평가</strong></p>
<p>최고 성능 모델을 테스트셋에 적용하여 훈련된 모델의 성능을 최종 평가한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X_test</span> <span class="o">=</span> <span class="n">strat_test_set</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="n">strat_test_set</span><span class="p">[</span><span class="s2">&quot;median_house_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">final_predictions</span> <span class="o">=</span> <span class="n">final_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="n">final_rmse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">final_predictions</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="id28">
<h2><span class="section-number">2.8. </span>최적 모델 저장과 활용<a class="headerlink" href="#id28" title="Permalink to this heading">#</a></h2>
<p>최적의 모델을 훈련시키는 과정이 매우 길 수 있다.
따라서 한 번 훈련된 좋은 모델은 저장해 놓고 필요할 때 불러와서 바로 사용할 수 있도록 해둔다.
이 뿐만 아니라 업데이트된 모델이 적절하지 않은 경우 이전 모델로 되돌려야 하는 상황이 발생할 수도 있다.</p>
<p>모델의 저장과 불러오기는 <code class="docutils literal notranslate"><span class="pre">joblib</span></code> 모듈을 활용한다.</p>
<ul>
<li><p>저장하기</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">final_model</span><span class="p">,</span> <span class="s2">&quot;my_california_housing_model.pkl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>불러오기</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">final_model_reloaded</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;my_california_housing_model.pkl&quot;</span><span class="p">)</span>
<span class="n">final_model_reloaded</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="id29">
<h2><span class="section-number">2.9. </span>연습문제<a class="headerlink" href="#id29" title="Permalink to this heading">#</a></h2>
<p>참고: <a class="reference external" href="https://colab.research.google.com/github/codingalzi/handson-ml3/blob/master/practices/practice_end2end_ml_project_1.ipynb">(실습) 머신러닝 프로젝트 처음부터 끝까지 1부</a> 와
<a class="reference external" href="https://colab.research.google.com/github/codingalzi/handson-ml3/blob/master/practices/practice_end2end_ml_project_2.ipynb">(실습) 머신러닝 프로젝트 처음부터 끝까지 2부</a></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="ml_landscape.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">1. </span>한눈에 보는 머신러닝</p>
      </div>
    </a>
    <a class="right-next"
       href="classification.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">3. </span>분류</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">2.1. 실전 데이터 활용</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">2.2. 큰 그림 그리기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">2.2.1. 데이터 정보 확인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">2.2.2. 훈련 모델 확인</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">2.3. 데이터 훑어보기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">2.3.1. 데이터 기본 정보 확인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">2.3.2. 훈련셋과 테스트셋</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">2.4. 데이터 탐색과 시각화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">2.4.1. 지리적 데이터 시각화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.4.2. 상관관계 조사</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">2.5. 데이터 준비</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">2.5.1. 데이터 정제와 전처리</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.5.2. 데이터 정제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.5.3. 범주형 특성 전처리: 원-핫 인코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">2.5.4. 수치형 특성 전처리: 크기 조정</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2.5.5. 사용자 정의 변환기</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#functiontransformer">2.5.5.1. <code class="docutils literal notranslate"><span class="pre">FunctionTransformer</span></code> 변환기</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.5.5.2. 사용자 정의 변환기 클래스 선언: 군집 변환기</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">2.5.6. 변환 파이프라인</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">2.5.7. 캘리포니아 데이터셋 변환 파이프라인</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">2.6. 모델 선택과 훈련</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">2.6.1. 모델 훈련과 평가</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">2.6.2. 교차 검증</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">2.7. 모델 미세 조정</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">2.7.1. 그리드 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id26">2.7.2. 랜덤 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id27">2.7.3. 최적 모델 활용</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id28">2.8. 최적 모델 저장과 활용</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">2.9. 연습문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>